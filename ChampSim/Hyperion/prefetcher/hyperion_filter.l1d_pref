#include "vbertimix.h"
#include "bingo_frame.h"
#define LANZAR_INT 8
// 采用前三次访问判断page模式的方式进行
// Last edit: 27 - Sept - 2021 12:10
#define LOG2_BLOCKS_PER_PAGE 6

//data structure:
//(1) filter table: fully-associated, lru, page to tag
//(2) history table: fully-associated, lru, hash(page,pc) or page to index
//(3) delta table:fully-associated, lru, hash(page,pc) or page to index

// FIFO queue
//#define SIZE_RR 16
//uint64_t RR[NUM_CPUS][SIZE_RR] = {0};
//uint64_t RR_cycle[NUM_CPUS][SIZE_RR] = {0};
//uint64_t RR_dx[NUM_CPUS] = {0};
#define PAGE
#define PAGE_PREF
// #define OFFSET
// #define GLOBAL
bool spec_intructions_complete;
uint64_t global_first_offset;
int debug_level;
struct PAGE_SETTING{
    const uint64_t BIG_REGION_SIZE = 64 * 16;//blocks
    const uint64_t SMALL_REGION_SIZE = 64;//blocks
    const uint64_t FILTER_TABLE = 128;
    const uint64_t ACCUMULATE_TABLE=128;
    const uint64_t OFFSET_RECORD_NUMBER=16;
    const uint64_t DELTA_NUMBER=16;
    const uint64_t STRIDE_COUNT_TABLE=32;
    const uint64_t INTERVAL=100;
    const float PAGE_L1_THRESHOLD=0.6;
    const float PAGE_L2_THRESHOLD=0.15;
    const float PAGE_LLC_THRESHOLD=0.2;
    const float GLOBAL_STRIDE_THRESHOLD=0.65;
    // const float GLOBAL_STRIDE_THRESHOLD=2.0;
    const float GLOBAL_STRIDE_THRESHOLD_LLC=GLOBAL_STRIDE_THRESHOLD;
    const int MAX_PF_S = 16;
    const int MAX_PF_LAUNCH_S = 6;
    const int PAGE_MAX_PF_LAUNCH_S = 12;
    const int ALL_MAX_PF = 12;
    const uint64_t PAGE_CONFIDENCE_MAX = 16;
    const uint64_t PAGE_LANZAR_INT = 8;



    void print(){
            cerr  << "====================================================="<<endl;
            cerr  <<  "ACCUMULATE_TABLE:         "   <<ACCUMULATE_TABLE<<endl;
            cerr  << "====================================================="<<endl;
    }

};

struct global_setting{
    const uint64_t GLOBAL_HISTORY_NUMBER = 16;
};


struct Berti_SETTING{
    const uint64_t CONFIDENCE_INC_S = 1;
    const uint64_t CONFIDENCE_INIT_S = 1;
    const int CONFIDENCE_L1_S = 65;
    const uint64_t CONFIDENCE_L2_S = 50;
    const uint64_t CONFIDENCE_L2R_S = 35;
    const uint64_t HISTORY_TABLE_SET_S = 32;
    const uint64_t HISTORY_TABLE_WAY_S = 64;
    const uint64_t TABLE_SET_MASK_S = (1<<HISTORY_TABLE_SET_S)-1;
    const uint64_t BERTI_TABLE_SIZE_S = 64;
    const uint64_t BERTI_TABLE_STRIDE_SIZE_S = 16;
};
struct stride_info {
    int64_t stride;
    uint64_t conf;
    uint64_t prefetch_level; 
    uint64_t lru;
};
struct _Strides{
    vector<stride_info> conf_page_stride;
};

struct Berti_SETTING berti_setting;

struct stat_info{
    uint64_t ip_prefetch_nums;
    uint64_t page_prefetch_nums;
    uint64_t global_prefetch_nums;
    uint64_t prefetch_times;

    vector<uint64_t> ips;
    vector<uint64_t> pages;

    float mshr_occupancy;
    uint64_t access_times;

    uint64_t get_vector_max(vector<uint64_t> numbers){
        uint64_t maxIndex = 0;
        uint64_t maxValue = numbers[0];
        
        for (uint64_t i = 1; i < numbers.size(); i++) {
            if (numbers[i] > maxValue) {
                maxValue = numbers[i];
                maxIndex = i;
            }
        }
        return maxIndex;
    }


    uint64_t berti_long; //访问delta table，对应条目的总访问次数小于16
    bool berti_long_true;
    uint64_t berti_get;   //访问delta table，里面有一个条目
    uint64_t berti_access;//访问delta table总次数
    uint64_t berti_conf;//有conf delta的访问次数
    bool berti_conf_true;

    

    uint64_t page_long;
    bool page_long_true;
    uint64_t page_get;
    uint64_t page_access;
    uint64_t page_conf;
    bool page_conf_true;

    uint64_t offset_long;
    bool offset_long_true;
    uint64_t offset_get;
    uint64_t offset_access;
    uint64_t offset_conf;
    bool offset_conf_true;

    uint64_t global_long;
    bool global_long_true;
    uint64_t global_get;
    uint64_t global_access;
    uint64_t global_conf;
    bool global_conf_true;

    uint64_t all_long;
    uint64_t all_conf;


    void reset(){
        ip_prefetch_nums = 0;
        page_prefetch_nums = 0;
        global_prefetch_nums = 0;
        prefetch_times = 0;
        for(int i =0; i<16;i++){
            ips.push_back(0);
            pages.push_back(0);
        }
        mshr_occupancy = 0;
        access_times=0;
    
    berti_long = 0;
    berti_long_true = false;
    berti_get = 0;
    berti_access = 0;
    berti_conf = 0;
    berti_conf_true= false;



    page_long = 0;
    page_long_true = false;
    page_get = 0;
    page_access = 0;
    page_conf = 0;
    page_conf_true = false;

    offset_long = 0;
    offset_long_true = false;
    offset_get = 0;
    offset_access = 0;
    offset_conf = 0;
    offset_conf_true = false;

    global_long = 0;
    global_long_true = false;
    global_get = 0;
    global_access = 0;
    global_conf = 0;
    global_conf_true = false;

    all_long = 0;
    all_conf = 0;
    }

    
};
struct stat_info stat;
uint8_t warmup_flag_l1 = 0;

void notify_prefetch(uint64_t addr, uint64_t tag, uint32_t cpu, uint64_t cycle)
{
    //这个是预取时，进入到缺失状态寄存器的时间
    latency_table_add(addr, tag, cpu, 0, cycle & TIME_MASK);
}

bool compare_greater_stride_t(stride_t a, stride_t b)
{
    if (a.rpl == L1 && b.rpl != L1) return 1;
    else if (a.rpl != L1 && b.rpl == L1) return 0;
    else
    {
        if (a.rpl == L2 && b.rpl != L2) return 1;
        else if (a.rpl != L2 && b.rpl == L2) return 0;
        else
        {
            if (a.rpl == L2R && b.rpl != L2R) return 1;
            if (a.rpl != L2R && b.rpl == L2R) return 0;
            else
            {
                if (std::abs(a.stride) < std::abs(b.stride)) return 1;
                return 0;
            }
        }
    }
}

bool compare_greater_stride_t_per(stride_t a, stride_t b)
{
    if (a.per > b.per) return 1;
    else
    {
        if (std::abs(a.stride) < std::abs(b.stride)) return 1;
        return 0;
    }
}

/******************************************************************************/
/*                      Latency table functions                               */
/******************************************************************************/
void latency_table_init(uint32_t cpu)
{
    /*
     * Init pqmshr (latency) table
     *
     * Parameters:
     *      - cpu: cpu
     */
    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        latencyt[cpu][i].tag  = 0;
        latencyt[cpu][i].addr = 0;
        latencyt[cpu][i].time = 0;
        latencyt[cpu][i].pf   = 0;
    }
}

uint64_t latency_table_get_ip(uint64_t line_addr, uint32_t cpu)
{
    /*
     * Return 1 or 0 if the addr is or is not in the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *
     * Return: 1 if the line is in the latency table, otherwise 0
     */

    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Search if the line_addr already exists
        if (latencyt[cpu][i].addr == line_addr && latencyt[cpu][i].tag) 
            return latencyt[cpu][i].tag;
    }

    return 0;
}

uint8_t latency_table_add(uint64_t line_addr, uint64_t tag, uint32_t cpu, 
        uint8_t pf)
{
    /*
     * Save if possible the new miss into the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *  - access: is the entry accessed by a demand request
     */
    return latency_table_add(line_addr, tag, cpu, pf, current_core_cycle[cpu] & TIME_MASK);
}

uint8_t latency_table_add(uint64_t line_addr, uint64_t tag, uint32_t cpu, 
        uint8_t pf, uint64_t cycle)
{
    /*
     * Save if possible the new miss into the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *  - access: is theh entry accessed by a demand request
     *  - cycle: time to use in the latency table
     *
     * Return: 1 if the addr already exist, otherwise 0.
     */

    latency_table_t *free;
    free = nullptr;

    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Search if the line_addr already exists. If it exist we does not have
        // to do nothing more
        if (latencyt[cpu][i].addr == line_addr) 
        {
            latencyt[cpu][i].time = cycle;
            latencyt[cpu][i].tag  = tag;
            latencyt[cpu][i].pf   = pf;
            return latencyt[cpu][i].pf;
        }

        // We discover a free space into the latency table, save it for later
        //if (latencyt[cpu][i].addr == 0) free = &latencyt[cpu][i];
        if (latencyt[cpu][i].tag == 0) free = &latencyt[cpu][i];
    }

    // No free space!! This cannot be truth
    if (free == nullptr) return 0;

    // We save the new entry into the latency table
    free->addr = line_addr;
    free->time = cycle;
    free->tag  = tag;
    free->pf   = pf;

    return free->pf;
}

uint64_t latency_table_del(uint64_t line_addr, uint32_t cpu)
{
    /*
     * Remove the address from the latency table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *
     *  Return: the latency of the address
     */
    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Line already in the table
        if (latencyt[cpu][i].addr == line_addr)
        {
            uint64_t latency = (current_core_cycle[cpu] & TIME_MASK)
                - latencyt[cpu][i].time; // Calculate latency

            //latencyt[cpu][i].addr = 0; // Free the entry
            latencyt[cpu][i].tag  = 0; // Free the entry
            latencyt[cpu][i].time = 0; // Free the entry
            latencyt[cpu][i].pf   = 0; // Free the entry

            // Return the latency
            return latency;
        }
    }

    // We should always track the misses
    //assert(0);
    return 0;
}

uint64_t latency_table_get(uint64_t line_addr, uint32_t cpu)
{
    /*
     * Return 1 or 0 if the addr is or is not in the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *
     * Return: 1 if the line is in the latency table, otherwise 0
     */

    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Search if the line_addr already exists
        if (latencyt[cpu][i].addr == line_addr) return latencyt[cpu][i].time;
    }

    return 0;
}

/******************************************************************************/
/*                       Shadow Cache functions                               */
/******************************************************************************/
void shadow_cache_init(uint32_t cpu)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     */
    for (uint8_t i = 0; i < L1D_SET; i++)
    {
        for (uint8_t ii = 0; ii < L1D_WAY; ii++)
        {
            scache[cpu][i][ii].addr = 0;
            scache[cpu][i][ii].lat  = 0;
            scache[cpu][i][ii].pf   = 0;
        }
    }
}

uint8_t shadow_cache_add(uint32_t cpu, uint32_t set, uint32_t way, 
        uint64_t line_addr, uint8_t pf, uint64_t latency)
{
    /*
     * Add block to shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - set: cache set
     *      - way: cache way
     *      - addr: cache block v_addr
     *      - access: the cache is access by a demand
     */
    scache[cpu][set][way].addr = line_addr;
    scache[cpu][set][way].pf   = pf;
    scache[cpu][set][way].lat  = latency;
    return scache[cpu][set][way].pf;
}

uint8_t shadow_cache_get(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) return 1;
        }
    }

    return 0;
}

uint8_t shadow_cache_pf(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) 
            {
                scache[cpu][i][ii].pf = 0;
                return 1;
            }
        }
    }

    return 0;
}

uint8_t shadow_cache_is_pf(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) return scache[cpu][i][ii].pf;
        }
    }

    return 0;
}

uint8_t shadow_cache_latency(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) return scache[cpu][i][ii].lat;
        }
    }
    assert(0);
    return 0;
}

struct FilterData_cell{
        uint64_t pc;
        uint64_t offset;
        uint64_t timestamp;
};
class FilterTableData{
public:
    FilterData_cell entry_data[2];
    
};
class FilterTable : public LRUFullyAssociativeCache<FilterTableData>{
    typedef LRUFullyAssociativeCache<FilterTableData> Super;
    public: 
        FilterTable(int size) : Super(size){
            cerr<<"FilterTable sets: "<< num_sets<<" ways: "<<num_ways<<endl;

        }
        int insert(uint64_t region_number, uint64_t offset, uint64_t pc, uint64_t cycle){
            Entry *entry = Super::find(region_number);
            if(!entry){
                FilterTableData data;           
                data.entry_data[0].pc = pc;
                data.entry_data[0].offset = offset;
                data.entry_data[0].timestamp = cycle;
                data.entry_data[1].pc = 0 ;
                data.entry_data[1].offset = 0;
                data.entry_data[1].timestamp = 0;
                Entry victim = Super::insert(region_number,data);
                this->set_mru(region_number);
                if(this->debug_level>=2){
                    cerr  << "[FT] Insert new page: "<<  region_number << " offsets: "<< offset <<endl;
                }
                return 0;
            }
            else{
                this->set_mru(region_number);
                //不记录重复的offset
                for(auto &access : entry->data.entry_data){
                    if(offset == access.offset){
                        return 0;
                    }
                }
                if(entry->data.entry_data[1].pc != 0){
                    // A pc0 == pc1 , B: pc0 = pc2  C:pc1=pc2
                    bool A = (entry->data.entry_data[0].pc == entry->data.entry_data[1].pc);
                    bool B = (entry->data.entry_data[0].pc == pc);
                    bool C = (entry->data.entry_data[1].pc == pc);
                    //cross
                    bool crossA = (!((entry->data.entry_data[1].offset/ 64) ==  (entry->data.entry_data[0].offset / 64))) ||(std::abs(int64_t(entry->data.entry_data[0].offset)-int64_t(entry->data.entry_data[1].offset))>= 32) ; 
                    bool crossB = (!((offset/ 64) == (entry->data.entry_data[0].offset / 64)))||(std::abs(int64_t(offset)-int64_t(entry->data.entry_data[0].offset))>= 32);
                    bool crossC = (!((offset/ 64) == (entry->data.entry_data[1].offset / 64)))||(std::abs(int64_t(offset)-int64_t(entry->data.entry_data[1].offset))>= 32);;
                    //
                    // if(A && B && C) {
                    //     if(crossA || crossC || crossB){
                    //         if(this->debug_level>=2){
                    //             cerr  << "[FT] Check page: "<<  region_number << " pc+page, big page " <<endl;
                    //         }
                    //         return 1; //pc+big_region
                    //     }else if((!crossA) && (!crossC) ){
                    //         if(this->debug_level>=2){
                    //             cerr  << "[FT] Check page: "<<  region_number << " pc+page, small page " <<endl;
                    //         }
                    //         return 1;//pc+small_region
                    //     }
                    // }else if((A&&(!B)&&(crossA))||(B&&(!C)&&crossB)||(C&&(!A)&&crossC)){
                    //     if(this->debug_level>=2){
                    //         cerr  << "[FT] Check page: "<<  region_number << " pc+page, big page " <<endl;
                    //     }
                    //     return 1; //pc+big_region
                    // }else if((A&&(!B)&&(!crossA))||(B&&(!C)&&(!crossB))||(C&&(!A)&&(!crossC))){
                    //     if(this->debug_level>=2){
                    //         cerr  << "[FT] Check page: "<<  region_number << " pc+page, small page " <<endl;
                    //     }
                    //     return 1; //pc+big_region
                    // }
                    // else{
                    //     if(this->debug_level>=2){
                    //             cerr  << "[FT] Check page: "<<  region_number << " small page " <<endl;
                    //      }
                    //     return 3;//small region
                    // }
                    if((!A)&&(!B)&&(!C)&&(!crossA)&&(!crossC)){
                        return 3;
                    }else{
                        return 1;
                    }
                }
                else{
                    if(this->debug_level>=2){
                        cerr  << "[FT] add offset: "<<  region_number << " pc " << pc << " offset " << offset <<endl;
                    }
                    entry->data.entry_data[1].pc = pc ;
                    entry->data.entry_data[1].offset = offset;
                    entry->data.entry_data[1].timestamp = cycle;
                    return 0;
                }
            }
        }

        FilterTableData get(uint64_t region_number){
            Entry *entry = Super::find(region_number);
            if(this->debug_level>=2){
                cerr  << "[FT] get offset, page: "<<  region_number <<endl;
            }
            FilterTableData data = entry->data;
            Super::erase(region_number);
            return data;
        }
};

struct Delta_info {
    int64_t stride;
    uint64_t conf;
    uint64_t prefetch_level; 
    uint64_t lru;
};
class AccululateTableData {
public:
    deque<int> offsets;
    deque<uint64_t> latencys;
    uint64_t total;
    vector<Delta_info> strides;
    // vector<uint64_t> train_stride;
    
};
bool compareByConf(const Delta_info& s1, const Delta_info& s2) {

    if(s1.prefetch_level != s2.prefetch_level){
        return s1.prefetch_level < s2.prefetch_level ;
    }else{
        return s1.conf > s2.conf;
    }
}
bool compareByOnlyConf(const Delta_info& s1, const Delta_info& s2) {
    return s1.conf > s2.conf;
}
class AccululateTable : public LRUFullyAssociativeCache<AccululateTableData> {
    typedef LRUFullyAssociativeCache<AccululateTableData> Super;
    public:
        AccululateTable(int size,int offset_number,int strides_number,
        uint64_t confidence_max, uint64_t l1_thres, uint64_t l2_thres, uint64_t llc_thres) : Super(size),offset_number(offset_number), strides_number(strides_number), 
        confidence_max(confidence_max),
        l1_thres(l1_thres),l2_thres(l2_thres),llc_thres(llc_thres)
        {
            cerr<<"AccululateTable sets: "<< num_sets<<" ways: "<<num_ways<<endl;
        }
        int insert(uint64_t tag, uint64_t offset, uint64_t timestamp, bool add_new){
            Entry *entry = Super::find(tag);
            if(!entry){   
                if(add_new){
                    AccululateTableData at_entry;
                    at_entry.offsets.push_back(offset);
                    at_entry.latencys.push_back(timestamp);
                    at_entry.total = 0;
                    Entry victim = Super::insert(tag,at_entry);
                    this->set_mru(tag);
                    if(this->debug_level>=2){
                        cerr  << "[AT] Insert new entry, tag: "<<  tag <<endl;
                    }
                    return 1;
                }   
                else{
                    return 0;
                }
            }else{
                this->set_mru(tag);
                for (size_t i = 0; i < entry->data.offsets.size(); ++i) {
                    if(entry->data.offsets[i] == offset){
                        return 1;
                    }
                } 
                if(entry->data.offsets.size()>= this->offset_number){
                    entry->data.offsets.pop_front();
                    entry->data.latencys.pop_front();
                }
                entry->data.offsets.push_back(offset);
                entry->data.latencys.push_back(timestamp);
                if(this->debug_level>=2){
                    cerr  << "[AT] Insert new offset, tag: "<<  tag << ", timestamp: " << timestamp << " offsets: "<< dequeToString(entry->data.offsets) <<endl;
                }
                return 1;
            }
        }

        int update_stride(uint64_t tag,uint64_t offset, uint64_t latency, uint64_t cycle){
            Entry *entry = Super::find(tag);
            if(!entry){
                if(this->debug_level>=2){
                    cerr  << "[AT] No stride. tag: "<< tag << endl;
                }
                return 0;
            }else{
                if(cycle < latency) return 0;
                cycle = cycle - latency;
                int cnt = 0;
                this->set_mru(tag);
                for (size_t  i = entry->data.offsets.size(); i-->0;) {
                    if( entry->data.latencys[i] < cycle ){
                        int64_t delta = offset - entry->data.offsets[i];
                        if(delta != 0 && std::abs(delta) < (1 << STRIDE_MASK)){
                            cnt = cnt + 1;
                            if(cnt == 1){
                                add_conf(tag);
                            }
                            stride_add(tag, delta);
                            if(this->debug_level>=2){
                                cerr  << "[AT] stride: " << delta <<" offset: " << offset<<" "<<entry->data.offsets[i]  << ", latency: " << latency << " cycle: "<< cycle <<endl;
                            } 
                            
                        }                          
                    }      
                }
                return cnt;
            }
        }

        int stride_add(uint64_t key, int64_t delta){
            Entry *entry = Super::find(key);
            for (size_t j = 0; j < entry->data.strides.size(); j++){
                if(entry->data.strides[j].stride == delta){
                    entry->data.strides[j].conf += CONFIDENCE_INC;
                    if (entry->data.strides[j].conf > CONFIDENCE_MAX) {
                        entry->data.strides[j].conf = CONFIDENCE_MAX;
                    }
                    return 1;
                }
            }
            std::sort(entry->data.strides.begin(), entry->data.strides.end(),compareByConf);
            if(entry->data.strides.size() >= this->strides_number){
                entry->data.strides.pop_back();
            }
            entry->data.strides.push_back({delta, 1,NO_PREFETCH,entry->data.total});
        }

        void add_conf(uint64_t tag){
            if(this->debug_level>=2){
                cerr  << "[AT_add_way_conf]" << endl;
            }
            Entry *entry = Super::find(tag);
            if(!entry){
                if(this->debug_level>=2){
                    cerr  << "[AT] t entry : no way found" <<endl;
                }  
            }
            else{
                entry->data.total = entry->data.total + 1;
                
                if(entry->data.total == confidence_max){
                    if(this->debug_level >= 2){
                        cerr << "[ADD_conf]:"<< endl;
                    }
                    for(auto& pair: entry->data.strides){
                        float conf_rate = 1.0*pair.conf / entry->data.total;
                        if(this->debug_level >= 2){
                            cerr << "stride_conf:"<< conf_rate << endl;
                        }
                        if(conf_rate > l1_thres){
                            if(this->debug_level>=2 ){
                                cerr  << "set_find_stride_conf: "<<conf_rate<<endl;
                            }
                            pair.prefetch_level = L1;
                        }else if(conf_rate > l2_thres){
                            if(this->debug_level>=2 ){
                                cerr  << "set_find_stride_conf: "<<conf_rate<<endl;
                            }
                            pair.prefetch_level = L2;
                        }else if(conf_rate > llc_thres){
                            if(this->debug_level>=2 ){
                                cerr  << "set_find_stride_conf: "<<conf_rate<<endl;
                            }
                            pair.lru = L2R;
                        }else{
                            
                            pair.prefetch_level = NO_PREFETCH;
                        }
                        if(this->debug_level >= 2){
                            cerr << '[AT_conf]:'<< endl;
                        }
                        pair.conf = 0;
                        pair.lru = 0;
                    }
                    entry->data.total = 1;
                }
            }
        }

        vector<Delta_info> get_conf_stride(uint64_t tag){
            vector<Delta_info> conf_stride;
            Entry *entry = Super::find(tag);
            if (!entry){
                if(this->debug_level>=2){
                cerr  << "[AT_get_stride] way not found"<<endl;
                }
                return conf_stride;
            }else{
                std::sort(entry->data.strides.begin(), entry->data.strides.end(), compareByConf);
                // cerr  << "[PST] get conf stride: "  << " page number: "<< region_num <<", size: " << entry->data.stride_conf.size() <<" total: "<< entry->data.total <<endl;
                for ( auto& pair : entry->data.strides) {
                    if(this->debug_level>=2){
                        cerr  << "stride: "<< pair.stride << " conf: " << pair.conf <<endl;
                    }
                    if(pair.stride!=0 && pair.prefetch_level < NO_PREFETCH){
                        
                        conf_stride.push_back({pair.stride, pair.conf, pair.prefetch_level});
                    }
                }

                if( conf_stride.size() ==0 && entry->data.total >= LANZAR_INT){
                    if(this->debug_level>=2){
                        cerr  << "[AT_get_stride] LANZAR"<<endl;
                    }
                    std::sort(entry->data.strides.begin(), entry->data.strides.end(), compareByOnlyConf);
                    for ( auto& pair : entry->data.strides) {
                        float conf_rate = 1.0*pair.conf/entry->data.total ;
                        if(this->debug_level>=2){
                            cerr  << "stride: "<< pair.stride << " conf: " << conf_rate << " entry_total: "<<entry->data.total <<endl;
                        }
                        if( conf_rate > l1_thres+0.15 ){
                            conf_stride.push_back({pair.stride, pair.conf, L1});
                        }else if(conf_rate > l2_thres+0.15){
                            conf_stride.push_back({pair.stride, pair.conf, L2});
                        }else{
                            break;
                        }
                    }
                }
                std::sort(conf_stride.begin(), conf_stride.end(), compareByConf);
                while(conf_stride.size() > this->offset_number){
                    conf_stride.pop_back();
                }
                if(this->debug_level>=2 ){
                    cerr << "[AT strides]: ";
                    for(size_t i = 0; i < conf_stride.size(); i++ ){
                        cerr << conf_stride[i].stride << " ";
                    }
                    cerr << endl;
                }             
            }
            return conf_stride;
        }
    private:
        uint64_t offset_number;
        uint64_t strides_number;
        uint64_t confidence_max;
        uint64_t l1_thres;
        uint64_t l2_thres;
        uint64_t llc_thres;
};




class StrideCountTableData {
  public:
    uint64_t cnt;
};

class StrideCountTable : public LRUFullyAssociativeCache<StrideCountTableData> {
    typedef LRUFullyAssociativeCache<StrideCountTableData> Super;
  public:
    StrideCountTable(int size, float threshold, uint64_t interval) : Super(size), global_threshold(threshold), interval(interval) {
        total_cnt = 0;
        select_stride = 0;
        rate = 0;
        cur_max = 0;
        cerr<<"StrideCountTable sets: "<< num_sets<<" ways: "<<num_ways<<endl;
        // assert(__builtin_popcount(size) == 1);
        // assert(__builtin_popcount(pattern_len) == 1);
    }
    uint64_t get_cnt(){
        return this->select_stride;
    }

    float get_threshold(){
        return rate;
    }

    uint64_t add_cnt(uint64_t pattern_number) {
        this->total_cnt++;
        if(this->total_cnt > this->interval && this->interval != 0 ){
            reset();
        }
        Entry *entry = Super::find(pattern_number);
        if (!entry){
            // assert(0);
            Entry victim =  Super::insert(pattern_number, {1});
            this->set_mru(pattern_number);
            // traverse_entry();
            if (this->debug_level >= 2) {
                cerr << "[Bingo] StrideCountTable insert stride: "   << " stride: " << pattern_number << endl;
                if(victim.valid){
                    cerr << "[Bingo] StrideCountTable replace stride: "   << " stride: " << victim.key <<", cnt: "<< victim.data.cnt  << endl;
                }
                
            }
            return 1;
        }
        entry->data.cnt = entry->data.cnt + 1 ;
        // if(entry->data.cnt > cur_max){
        //     cur_max = entry->data.cnt;
        //     this->select_stride = pattern_number;
            
        // }

        // this->rate = 1.0 * cur_max /( this->total_cnt+1);
        this->rate = 1.0 * entry->data.cnt / this->total_cnt;
        if( rate > this->global_threshold){
            this->select_stride = pattern_number;
        }
        this->set_mru(pattern_number);
        // traverse_entry();
        if (this->debug_level >= 2) {
            cerr  << "[Bingo] StrideCountTable add cnt: "   << " stride: " << entry->key <<", cnt: "<< entry->data.cnt << endl;
        }
        return entry->data.cnt;
    }

    void traverse_entry(){
        auto &set = this->entries[0];
        for (int i = 0; i < num_ways; i += 1){
            if (set[i].valid){
                cerr<<"Traverse way: "<< i<< ", tag : "<< set[i].key <<" cnt: " << set[i].data.cnt <<" lru: " << (*get_lru(0,i))<<endl;
            }
        }    
    }

    void set_debug_level(int debug_level) { this->debug_level = debug_level; }

    bool reset() {
        auto &set = this->entries[0];
        auto &cam = cams[0];
        // assert(set.size() == size);
        assert(this->num_sets == 1);
        assert(this->num_ways == size);
        for (int i = 0; i < num_ways; i += 1){
            if (set[i].valid){
                set[i].valid =false;
            }
        }

        // for (int i = 0; i < num_sets; i += 1){
        //     if (set[i].valid){
        //         set[i].valid =false;
        //     }
        // }

        cam.clear();
        // for (int i = 0; i < num_sets; i += 1)
        //     for (int j = 0; j < num_ways; j += 1)
        //         entries[i][j].valid = false;

    //    traverse_entry();
        // set.clear();
        this->total_cnt = 1;
        this->select_stride = 0;
        this->rate = 0;
        this->cur_max = 0;
        return true;
    }

    private:
        uint64_t total_cnt;
        float global_threshold;
        uint64_t interval;
        uint64_t select_stride;
        uint64_t cur_max;
        float rate;


};


class MIX {
  public:

    MIX(struct PAGE_SETTING setting)
        : setting(setting),
        ft(setting.FILTER_TABLE),
        at1(16, setting.OFFSET_RECORD_NUMBER,setting.DELTA_NUMBER,CONFIDENCE_MAX,
        setting.PAGE_L1_THRESHOLD, setting.PAGE_L2_THRESHOLD, setting.PAGE_LLC_THRESHOLD),
        at2(setting.ACCUMULATE_TABLE, setting.OFFSET_RECORD_NUMBER,setting.DELTA_NUMBER,CONFIDENCE_MAX,
        setting.PAGE_L1_THRESHOLD, setting.PAGE_L2_THRESHOLD, setting.PAGE_LLC_THRESHOLD),
        pct(setting.STRIDE_COUNT_TABLE, setting.GLOBAL_STRIDE_THRESHOLD, setting.INTERVAL){   
            if (this->debug_level >= 2) {
                cerr << dec << "MIX_START" << endl;
            }
        }
    

    // void insert_pat(uint64_t line_addr, uint64_t latency){
    //     pat.insert(line_addr, latency);

    // }
    
    void insert_pct(uint64_t stride){
        pct.add_cnt(stride);
    }

    uint64_t get_pct(){
        return this->pct.get_cnt();
    }

    void update_stride(uint64_t baddr,uint64_t pc, uint64_t latency, uint64_t  cycle){
        uint64_t tag1 = hash_pc_bpage(pc,baddr);
        uint64_t tag2 = hash_pc_spage(pc,baddr);
        uint64_t tag3 = hash_spage(baddr);
        if(at1.find(tag1)){
            at1.update_stride(tag1, baddr%(setting.BIG_REGION_SIZE),latency, cycle);         
        }else if(at1.find(tag2)){
            at1.update_stride(tag2, baddr%(setting.SMALL_REGION_SIZE),latency, cycle);         
        }else if(at2.find(tag3)) {
            at2.update_stride(tag3, baddr%(setting.SMALL_REGION_SIZE),latency, cycle);         
        }
    }

    void cache_fill(uint64_t line_addr, uint64_t cycle, uint64_t latency, uint64_t pc){
        if(this->debug_level >= 2)
        {
            std::cout <<  "pc:"<<pc<<" ";
            std::cout << "offset:"<<(line_addr%(1<<LOG2_BLOCKS_PER_PAGE))<<" ";
            std::cout << "baddr:"<< line_addr<<" ";
            std::cout << "vpaddr:"<< (line_addr >> LOG2_BLOCKS_PER_PAGE)<<" ";
            std::cout << "CF" << std::endl;
        }
        if (this->debug_level >= 2) {
            cerr << "[MIX] cache fill(line_addr: "  << line_addr<< ", latency: " << latency << " )" << endl;
        }
        update_stride(line_addr,pc, latency,cycle);
        
    }

    void add_to_history(uint64_t line_addr, uint64_t pc, uint64_t cycle){
        uint64_t offset_bpage = line_addr % (setting.BIG_REGION_SIZE);
        uint64_t offset_spage = line_addr % (setting.SMALL_REGION_SIZE);
        if(at1.insert(hash_pc_bpage(pc,line_addr),offset_bpage,cycle, false)){
            if(debug_level >= 2){
                cerr << " [AT] find PC+bigpage " << endl;
            }         
        }
        else if(at1.insert(hash_pc_spage(pc,line_addr),offset_spage,cycle, false)){
            if(debug_level >= 2){
                cerr << " [AT] find PC+smallpage " << endl;
            }
        }else if(at2.insert(hash_spage(line_addr),offset_spage,cycle, false)){
            if(debug_level >= 2){
                cerr << " [AT] find smallpage " << endl;
            }
        }
        else{
            if(debug_level >= 2){
                cerr << " [AT] no find, add to FT" << endl;
            }
            int type = ft.insert(line_addr/setting.BIG_REGION_SIZE,offset_bpage, pc, cycle);
            if(type != 0){
                if (this->debug_level >= 2) {
                    cerr << " [FT] entry has two offset" << endl;
                }
                FilterTableData ft_entry = ft.get(line_addr/setting.BIG_REGION_SIZE);
                uint64_t baddr0 = ft_entry.entry_data[0].offset + (line_addr / setting.BIG_REGION_SIZE)*setting.BIG_REGION_SIZE;
                uint64_t baddr1 = ft_entry.entry_data[1].offset + (line_addr / setting.BIG_REGION_SIZE)*setting.BIG_REGION_SIZE;
                uint64_t offset0_of_spage = ft_entry.entry_data[0].offset % setting.SMALL_REGION_SIZE;
                uint64_t offset1_of_spage = ft_entry.entry_data[1].offset % setting.SMALL_REGION_SIZE;
                if(type == 1){
                    at1.insert(hash_pc_bpage(pc,line_addr),offset_bpage,cycle, true);
                    at1.insert(hash_pc_bpage(pc,line_addr),ft_entry.entry_data[0].offset,cycle, true);
                    at1.insert(hash_pc_bpage(pc,line_addr),ft_entry.entry_data[1].offset,cycle, true);
                }else if(type == 2){
                    at1.insert(hash_pc_spage(ft_entry.entry_data[0].pc,baddr0),offset0_of_spage ,ft_entry.entry_data[0].timestamp, true);
                    at1.insert(hash_pc_spage(ft_entry.entry_data[1].pc,baddr1),offset1_of_spage ,ft_entry.entry_data[1].timestamp, true);
                    at1.insert(hash_pc_spage(pc,line_addr),offset_spage,cycle, true);
                }
                else{
                    at2.insert(hash_spage(baddr0),offset0_of_spage ,ft_entry.entry_data[0].timestamp, true);
                    at2.insert(hash_spage(baddr1),offset1_of_spage,ft_entry.entry_data[1].timestamp, true);
                    at2.insert(hash_spage(line_addr),offset_spage,cycle, true);
                }
            }
        }       
    }

    vector<Delta_info>  access(uint32_t cpu, uint64_t line_addr, uint8_t cache_hit,uint64_t pc){


        // uint64_t line_addr = ((line_addr >> 1) ^ (line_addr >> 4));
        // line_addr = line_addr&PAGE_MASK ;
        uint64_t cycle = current_core_cycle[cpu] & TIME_MASK;
        if (this->debug_level >= 2) {
            cerr << "[MIX] access "<<" cache_hit: "   << (cache_hit==1) <<" pf: " << (shadow_cache_is_pf(cpu, line_addr) == 1 )<<", cycle "<< cycle  << endl;
            // cerr<<" rate: "<<rate<< endl;
        }

        uint64_t page_number = line_addr >> LOG2_BLOCKS_PER_PAGE;
        uint64_t offset = line_addr % (1 << LOG2_BLOCKS_PER_PAGE);


        if (!cache_hit){
            if(this->debug_level >= 2)
            {
                std::cout <<  "pc:"<<pc<<" ";
                std::cout << "offset:"<<(line_addr%(1<<LOG2_BLOCKS_PER_PAGE))<<" ";
                std::cout << "baddr:"<< line_addr<<" ";
                std::cout << "vpaddr:"<< (line_addr >> LOG2_BLOCKS_PER_PAGE)<<" ";
                std::cout << "M" << std::endl;
            }
            latency_table_add(line_addr, pc, cpu, 1);
            add_to_history(line_addr, pc, cycle);
            
        }else if (cache_hit && shadow_cache_is_pf(cpu, line_addr)){
            if(this->debug_level >= 2)
            {
                std::cout <<"pc:"<<pc<<" ";
                std::cout << "offset:"<<(line_addr%(1<<LOG2_BLOCKS_PER_PAGE))<<" ";
                std::cout << "baddr:"<< line_addr<<" ";
                std::cout << "vpaddr:"<< (line_addr >> LOG2_BLOCKS_PER_PAGE)<<" ";
                std::cout << "PH" << std::endl;
            }
            add_to_history(line_addr, pc, cycle);
            uint64_t latency = shadow_cache_latency(cpu, line_addr);
            update_stride(line_addr, pc, latency,cycle);

        }else{
            if(this->debug_level >= 2)
            {
                std::cout <<"pc:"<<pc<<" ";
                std::cout << "offset:"<<(line_addr%(1<<LOG2_BLOCKS_PER_PAGE))<<" ";
                std::cout << "baddr:"<< line_addr<<" ";
                std::cout << "vpaddr:"<< (line_addr >> LOG2_BLOCKS_PER_PAGE)<<" ";
                std::cout << "H" << std::endl;
            }
            shadow_cache_pf(cpu, line_addr);
        }

        vector<Delta_info> strides;
        uint64_t tag1 = hash_pc_bpage(pc, line_addr);
        uint64_t tag2 = hash_pc_spage(pc, line_addr);
        uint64_t tag3 = hash_spage(line_addr);
        strides= at1.get_conf_stride(tag1);
        
        if(strides.empty()){
            strides= at1.get_conf_stride(tag2);
            if(strides.empty()){
                strides= at2.get_conf_stride(tag3);
            }
        }
        return strides;
    }



    float get_global_rate(){
        return this->pct.get_threshold();
    }


    void set_debug_level(int debug_level) { 
        this->debug_level = debug_level; 
        ft.set_debug_level(debug_level);
        at1.set_debug_level(debug_level);
        at2.set_debug_level(debug_level);
        pct.set_debug_level(debug_level);
    }
    
    private:
        uint64_t hash_pc_spage(uint64_t pc, uint64_t baddr){
            return ((pc >> 1)&(IP_MASK))^((baddr /setting.SMALL_REGION_SIZE)&(ADDR_MASK));
        }
        uint64_t hash_pc_bpage(uint64_t pc, uint64_t baddr){
            return ((pc >> 1)&(IP_MASK))^((baddr /setting.BIG_REGION_SIZE)&(ADDR_MASK));
        }
        uint64_t hash_spage(uint64_t baddr){
            return ((baddr /setting.SMALL_REGION_SIZE)&(ADDR_MASK));
        }
        struct PAGE_SETTING setting;
        FilterTable ft;
        AccululateTable at1;
        AccululateTable at2;
        StrideCountTable pct;
        int debug_level = 0;

};

vector<MIX> prefetchers;


struct PAGE_SETTING setting;

void CACHE::l1d_prefetcher_initialize() 
{
    shadow_cache_init(cpu);
    latency_table_init(cpu);

    
    stat.reset();

    prefetchers = vector<MIX>(NUM_CPUS, MIX(setting));
    for(int i =0; i<NUM_CPUS; i++){
        prefetchers[i].set_debug_level(0);
    }
    std::cout << "History Sets: " << HISTORY_TABLE_SET << std::endl;
    std::cout << "History Ways: " << HISTORY_TABLE_WAY << std::endl;
    std::cout << "BERTI Size: " << BERTI_TABLE_SIZE << std::endl;
    std::cout << "BERTI Stride Size: " << BERTI_TABLE_STRIDE_SIZE << std::endl;
    
    
    spec_intructions_complete = false;
    global_first_offset = 64;
    debug_level = 0;
}
bool set_debug = false;
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit,
        uint8_t type, uint8_t critical_ip_flag)
{
    if((!set_debug) && spec_intructions_complete == true){
        for(int i =0; i<NUM_CPUS; i++){
            prefetchers[i].set_debug_level(0);
            debug_level = 0;
        }
        set_debug = true;
    }
    
    assert(type == LOAD || type == RFO);

    if(warmup_complete[cpu] && warmup_flag_l1 == 0){
        stat.reset();
        warmup_flag_l1 = 1;
    }

    uint64_t line_addr = (addr >> LOG2_BLOCK_SIZE); // Line addr
    uint64_t pc = ip;
 
    vector<Delta_info> strides;
    // cerr<<"here"<<endl;
    // conf_stride = prefetchers[cpu].get_conf_stride(line_addr);
    
    strides = prefetchers[cpu].access(cpu, line_addr, cache_hit,pc);


    if((1.0 * MSHR.occupancy / (float) MSHR_SIZE) == 1 ){
        stat.mshr_occupancy++;
    }
    stat.access_times++;
    int total_prefetch = 0;

    int page_launched = 0;
    #ifdef PAGE_PREF
    for ( auto& stride_info : strides) {
    

        if( page_launched >= setting.PAGE_MAX_PF_LAUNCH_S  ){
            break;
        }

        
        uint64_t p_addr = (line_addr + stride_info.stride) << LOG2_BLOCK_SIZE;
        uint64_t p_b_addr = (p_addr >> LOG2_BLOCK_SIZE);

        if (!latency_table_get(p_addr, cpu)){
            int fill_level = FILL_L1;
            float mshr_load = ((float) MSHR.occupancy / (float) MSHR_SIZE) * 100;
            if (stride_info.prefetch_level == L1 && mshr_load < MSHR_LIMIT){
                fill_level = FILL_L1;
            } else if (stride_info.prefetch_level == L2 ){ 
                fill_level = FILL_L2;
            } else  if ( stride_info.prefetch_level == L2R ){
                fill_level = FILL_LLC;
            }else{
                break;
            }

            if (prefetch_line(pc, addr, p_addr, fill_level, 1)){
                if(fill_level == FILL_L1){
                    prefetchers[cpu].insert_pct(uint64_t(stride_info.stride));
                }
                // assert(0);
                page_launched++;
                total_prefetch++;
            }

        }
    }
    #endif
    stat.page_prefetch_nums+=page_launched;
    if(page_launched!=0){
        stat.pages[page_launched]++;
    }
    

    
    int64_t global_stride = int64_t(prefetchers[cpu].get_pct());
    // uint64_t global_stride =0;
    if(global_stride!=0 && (page_launched ) < setting.ALL_MAX_PF){
        int fill_level = -1;
        if(prefetchers[cpu].get_global_rate() > setting.GLOBAL_STRIDE_THRESHOLD ){
             fill_level = FILL_L2;
        } else if(prefetchers[cpu].get_global_rate() > setting.GLOBAL_STRIDE_THRESHOLD_LLC ){
             fill_level = FILL_LLC;
        } 
    }
    stat.global_prefetch_nums+= total_prefetch - (page_launched);

    if(total_prefetch != 0){
        stat.prefetch_times++;
    }
    
}

void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, 
        uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, 
        uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, 
        uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, 
        uint64_t evicted_addr, uint32_t metadata_in)
{
    uint64_t line_addr = (v_addr >> LOG2_BLOCK_SIZE); // Line addr
    uint64_t line_evicted = (v_evicted_addr >> LOG2_BLOCK_SIZE); // Line addr

    // Remove @ from latency table
    uint64_t pc     = latency_table_get_ip(line_addr, cpu);
    uint64_t cycle   = latency_table_get(line_addr, cpu);
    uint64_t latency = latency_table_del(line_addr, cpu);

    if (latency > LAT_MASK) latency = 0;

    // Add to the shadow cache
    shadow_cache_add(cpu, set, way, line_addr, prefetch, latency);

    if (latency != 0 && !prefetch)
    {
        prefetchers[cpu].cache_fill(line_addr, current_core_cycle[cpu] & TIME_MASK,latency,pc);
    }

}

void CACHE::l1d_prefetcher_final_stats()
{
    cout << "* CPU " << "0" << " ROI ip prefetch number: " << stat.ip_prefetch_nums << endl;
    cout << "* CPU " << "0" << " ROI page prefetch number: " << stat.page_prefetch_nums << endl;
    cout << "* CPU " << "0" << " ROI global prefetch number: " << stat.global_prefetch_nums << endl;
    cout << "* CPU " << "0" << " ROI prefetch times: " << stat.prefetch_times << endl;

    int maxIndex = 0;
    int maxValue = stat.ips[0];


    cout << "* CPU " << "0" << " ROI ip prefetch degree: " << stat.get_vector_max(stat.ips) << endl;

    cout << "* CPU " << "0" << " ROI page prefetch degree: " << stat.get_vector_max(stat.pages) << endl;

    cout << "* CPU " << "0" << " ROI mshr occupancy: " << (stat.mshr_occupancy) << endl;
    cout << "* CPU " << "0" << " ROI access times: " << (stat.access_times) << endl;

    cout << "* CPU " << "0" << "berti:" << stat.berti_long<<" "<<stat.berti_get<<" "<<stat.berti_access<<" "<<stat.berti_conf<<std::endl;
    cout << "* CPU " << "0" << "all:" << stat.all_long << " "<<stat.all_conf<<std::endl;
}








