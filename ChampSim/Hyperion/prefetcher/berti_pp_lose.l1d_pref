#include "vbertim.h"
#include <sstream>
#include <iostream> //reocrd
#include <fstream>//record

#include <bits/stdc++.h>
#include <mutex> //atom ops
#include <unordered_map>
#include <unordered_set>

//******debug开关********//
#define RECORD_IP_ADDR false
//#define RECORD_DELTAS
#define LANZAR_INT 8


//******预取器开关*********//
#define BERTI_IP_ON
//#define BERTI_PAGES_ON
#define BERTI_PP_ON
#define BINGO_BOP_ON
//#define BINGO
//#define MLOP_ON
#define MIX_DELTA

#ifdef MIX_DELTA


    void mergeDelta(std::vector<mix_delta> &data, const mix_delta &newElement) 
    {
        for (mix_delta &elem : data) 
        {
            if (elem.pf_addr == newElement.pf_addr) 
            {
                elem.score += newElement.score;
                elem.prefetcher.push_back(newElement.prefetcher[0]);
                if(elem.fill_level > newElement.fill_level )
                {
                    elem.fill_level = newElement.fill_level;
                }
                return;
            }
        }
        data.push_back(newElement);
    }

    bool compare_delta_scores(const mix_delta &a, const mix_delta &b) 
    {
        return a.score > b.score;
    }
#endif

//#define BOP_ON
#ifdef BINGO_BOP_ON
    #define CONSTRAIN_BOP
    //#define CP_BINGO_BOP_ON
    #define BOP_L1
    //#define BOP_L2
    //#define BOP_DEBUG
#endif


#ifdef BINGO_BOP_ON
  class Table {
    public:
      Table(int width, int height) : width(width), height(height), cells(height, vector<string>(width)) {}

      void set_row(int row, const vector<string> &data, int start_col = 0) {
          assert(data.size() + start_col == this->width);
          for (unsigned col = start_col; col < this->width; col += 1)
              this->set_cell(row, col, data[col]);
      }

      void set_col(int col, const vector<string> &data, int start_row = 0) {
          assert(data.size() + start_row == this->height);
          for (unsigned row = start_row; row < this->height; row += 1)
              this->set_cell(row, col, data[row]);
      }

      void set_cell(int row, int col, string data) {
          assert(0 <= row && row < (int)this->height);
          assert(0 <= col && col < (int)this->width);
          this->cells[row][col] = data;
      }

      void set_cell(int row, int col, double data) {
          this->oss.str("");
          this->oss << setw(11) << fixed << setprecision(8) << data;
          this->set_cell(row, col, this->oss.str());
      }

      void set_cell(int row, int col, int64_t data) {
          this->oss.str("");
          this->oss << setw(11) << std::left << data;
          this->set_cell(row, col, this->oss.str());
      }

      void set_cell(int row, int col, int data) { this->set_cell(row, col, (int64_t)data); }

      void set_cell(int row, int col, uint64_t data) { this->set_cell(row, col, (int64_t)data); }

      string to_string() {
          vector<int> widths;
          for (unsigned i = 0; i < this->width; i += 1) {
              int max_width = 0;
              for (unsigned j = 0; j < this->height; j += 1)
                  max_width = max(max_width, (int)this->cells[j][i].size());
              widths.push_back(max_width + 2);
          }
          string out;
          out += Table::top_line(widths);
          out += this->data_row(0, widths);
          for (unsigned i = 1; i < this->height; i += 1) {
              out += Table::mid_line(widths);
              out += this->data_row(i, widths);
          }
          out += Table::bot_line(widths);
          return out;
      }

      string data_row(int row, const vector<int> &widths) {
          string out;
          for (unsigned i = 0; i < this->width; i += 1) {
              string data = this->cells[row][i];
              data.resize(widths[i] - 2, ' ');
              out += " | " + data;
          }
          out += " |\n";
          return out;
      }

      static string top_line(const vector<int> &widths) { return Table::line(widths, "┌", "┬", "┐"); }

      static string mid_line(const vector<int> &widths) { return Table::line(widths, "├", "┼", "┤"); }

      static string bot_line(const vector<int> &widths) { return Table::line(widths, "└", "┴", "┘"); }

      static string line(const vector<int> &widths, string left, string mid, string right) {
          string out = " " + left;
          for (unsigned i = 0; i < widths.size(); i += 1) {
              int w = widths[i];
              for (int j = 0; j < w; j += 1)
                  out += "─";
              if (i != widths.size() - 1)
                  out += mid;
              else
                  out += right;
          }
          return out + "\n";
      }

    private:
      unsigned width;
      unsigned height;
      vector<vector<string>> cells;
      ostringstream oss;
  };
  //##############定义BINGO_BOP中的RR Table采用的是一个直接映射的cache，这个cache的相连度为1#########
  //组相连cache
  template <class T> class SetAssociativeCache {
    public:
      class Entry {
        public:
          uint64_t key; //key的作用是什么？
          uint64_t index;
          uint64_t tag;
          bool valid;
          T data;
      };

      //初始化cache
      SetAssociativeCache(int size, int num_ways)
          : size(size), num_ways(num_ways), num_sets(size / num_ways), entries(num_sets, vector<Entry>(num_ways)),
            cams(num_sets) {
          assert(size % num_ways == 0);
          for (int i = 0; i < num_sets; i += 1)
              for (int j = 0; j < num_ways; j += 1)
                  entries[i][j].valid = false;
      }

      Entry *erase(uint64_t key) {
          Entry *entry = this->find(key);
          uint64_t index = key % this->num_sets; //index是组索引？
          uint64_t tag = key / this->num_sets;   //tag是行tag？
          auto &cam = cams[index];
          int num_erased = cam.erase(tag);
          if (entry)
              entry->valid = false;
          assert(entry ? num_erased == 1 : num_erased == 0);
          return entry;
      }

      /**
      * @return The old state of the entry that was written to.
      */
      Entry insert(uint64_t key, const T &data) {
          Entry *entry = this->find(key);
          if (entry != nullptr) {
              Entry old_entry = *entry;
              entry->data = data;
              return old_entry;
          }
          uint64_t index = key % this->num_sets;
          uint64_t tag = key / this->num_sets;
          vector<Entry> &set = this->entries[index];
          int victim_way = -1;
          for (int i = 0; i < this->num_ways; i += 1)
              if (!set[i].valid) {
                  victim_way = i;
                  break;
              }
          if (victim_way == -1) {
              victim_way = this->select_victim(index);
          }
          Entry &victim = set[victim_way];
          Entry old_entry = victim;
          victim = {key, index, tag, true, data};
          auto &cam = cams[index];
          if (old_entry.valid) {
              int num_erased = cam.erase(old_entry.tag);
              assert(num_erased == 1);
          }
          cam[tag] = victim_way;
          return old_entry;
      }

      Entry *find(uint64_t key) {
          uint64_t index = key % this->num_sets;
          uint64_t tag = key / this->num_sets;
          auto &cam = cams[index];
          if (cam.find(tag) == cam.end())
              return nullptr;
          int way = cam[tag];
          Entry &entry = this->entries[index][way];
          assert(entry.tag == tag && entry.valid);
          return &entry;
      }

        /**
      * For debugging purposes.
      */
      string log(vector<string> headers, function<void(Entry &, Table &, int)> write_data) {
          vector<Entry> valid_entries = this->get_valid_entries();
          Table table(headers.size(), valid_entries.size() + 1);
          table.set_row(0, headers);
          for (unsigned i = 0; i < valid_entries.size(); i += 1)
              write_data(valid_entries[i], table, i + 1);
          return table.to_string();
      }



      void set_debug_mode(bool enable) { this->debug = enable; }

    protected:
      /**
      * @return The way of the selected victim.
      */
      virtual int select_victim(uint64_t index) {
          /* random eviction policy if not overriden */
          return rand() % this->num_ways;
      }

      vector<Entry> get_valid_entries() {
          vector<Entry> valid_entries;
          for (int i = 0; i < num_sets; i += 1)
              for (int j = 0; j < num_ways; j += 1)
                  if (entries[i][j].valid)
                      valid_entries.push_back(entries[i][j]);
          return valid_entries;
      }

      int size;
      int num_ways;
      int num_sets;
      vector<vector<Entry>> entries;
      vector<unordered_map<uint64_t, int>> cams;
      bool debug = false;
  };
  //直接映射cache，继承自组相连cache
  template <class T> class DirectMappedCache : public SetAssociativeCache<T> {
      typedef SetAssociativeCache<T> Super;

    public:
      DirectMappedCache(int size) : Super(size, 1) {}
  };

  /** End Of Cache Framework **/

  class RecentRequestsTableData {
    public:
      uint64_t base_address;
  };

  //继承自直接映射cache，直接映射cache是组相连cache的一个特殊例子，组内的条目为1
  class RecentRequestsTable : public DirectMappedCache<RecentRequestsTableData> {
      typedef DirectMappedCache<RecentRequestsTableData> Super;

    public:
      RecentRequestsTable(int size) : Super(size) {
          assert(__builtin_popcount(size) == 1);
          this->hash_w = __builtin_ctz(size);
      }

      Entry insert(uint64_t base_address) {
          uint64_t key = this->hash(base_address);
          return Super::insert(key, {base_address});
      }

      bool find(uint64_t base_address) {
          uint64_t key = this->hash(base_address);
          return (Super::find(key) != nullptr);
      }

      string log() {
          vector<string> headers({"Hash", "Base Address"});
          return Super::log(headers, this->write_data);
      }

    private:
      static void write_data(Entry &entry, Table &table, int row) {
          table.set_cell(row, 0, bitset<20>(entry.key).to_string());
          table.set_cell(row, 1, entry.data.base_address);
      }

      /* The RR table is accessed through a simple hash function. For instance, for a 256-entry RR table, we XOR the 8
      * least significant line address bits with the next 8 bits to obtain the table index. For 12-bit tags, we skip the
      * 8 least significant line address bits and extract the next 12 bits. */
      uint64_t hash(uint64_t input) {
          int next_w_bits = ((1 << hash_w) - 1) & (input >> hash_w);
          uint64_t output = ((1 << 20) - 1) & (next_w_bits ^ input);
          if (this->debug) {
              cerr << "[RR] hash( " << bitset<32>(input).to_string() << " ) = " << bitset<20>(output).to_string() << endl;
          }
          return output;
      }

      int hash_w;
  };


  //#################定义类 BOP和 Bestoffsetlearning#######################
  class BestOffsetLearning {
    public:
      BestOffsetLearning(int blocks_in_page) : blocks_in_page(blocks_in_page) {
          /* Useful offset values depend on the memory page size, as the BO prefetcher does not prefetch across page
          * boundaries. For instance, assuming 4KB pages and 64B lines, a page contains 64 lines, and there is no point
          * in considering offset values greater than 63. However, it may be useful to consider offsets greater than 63
          * for systems having superpages. */
          /* We propose a method for offset sampling that is algorithmic and not totally arbitrary: we include in our list
          * all the offsets between 1 and 256 whose prime factorization does not contain primes greater than 5. */
          /* Nothing prevents a BO prefetcher to use negative offset values. Although some applications might benefit from
          * negative offsets, we did not observe any benefit in our experiments. Hence we consider only positive offsets
          * in this study. */

          //初始化offset，选取一系列素数
          for (int i = 1; i < blocks_in_page; i += 1) {
              int n = i;
              for (int j = 2; j <= 5; j += 1)
                  while (n % j == 0)
                      n /= j;
              if (n == 1)
                  offset_list.push_back({i, 0});
          }
      }

      /**
      * @return The current best offset.
      */
      int test_offset(uint64_t block_number, RecentRequestsTable &recent_requests_table) {
          int page_offset = block_number % this->blocks_in_page;
          //每次访问都对index_to_test加1，对不同的offset进行遍历测试
          Entry &entry = this->offset_list[this->index_to_test];
          //由于预取不会超过页面的大小，所以这个地方的寻找的X和X+D也应该在同一个页面，后续在L1中使用的时候，需要做一些改进
          #ifdef BINGO_BOP_ON
              bool found =
                  is_inside_page(page_offset - entry.offset) && recent_requests_table.find(block_number - entry.offset);
          #endif
          #ifdef CP_BINGO_BOP_ON
              bool found = recent_requests_table.find(block_number - entry.offset);            
          #endif
          if (this->debug) {
              cerr << "[BOL] testing offset=" << entry.offset << " with score=" << entry.score << endl;
              cerr << "[BOL] match=" << found << endl;
          }
          if (found) {
              entry.score += 1;
              if (entry.score > this->best_score) {
                  this->best_score = entry.score;
                  this->local_best_offset = entry.offset;
              }
          }
          this->index_to_test = (this->index_to_test + 1) % this->offset_list.size();
          /* test round termination */
          if (this->index_to_test == 0) {
              if (this->debug) {
                  cerr << "[BOL] round=" << this->round << " finished" << endl;
              }
              this->round += 1;
              /* The current learning phase finishes at the end of a round when either of the two following events happens
              * first: one of the scores equals SCOREMAX, or the number of rounds equals ROUNDMAX (a fixed parameter). */
              if (this->best_score >= SCORE_MAX || this->round == ROUND_MAX) {
                  #ifdef CONSTRAIN_BOP
                      if (this->best_score <= BAD_SCORE || (this->best_score < SCORE_MAX && this->round == ROUND_MAX)){
                          this->global_best_offset = 0; /* turn off prefetching */
                          #ifdef BOP_DEBUG
                              std::cout << "OFF BOP: " << this->best_score << " "<< this->global_best_offset << std::endl;
                          #endif
                      }
                      else{
                          this->global_best_offset = this->local_best_offset;
                          #ifdef BOP_DEBUG
                              std::cout<< "BOP ON: " << this->best_score << " "<< this->global_best_offset << std::endl;
                          #endif
                      }
                  #else
                      if (this->best_score <= BAD_SCORE)
                          this->global_best_offset = 0; /* turn off prefetching */
                      else
                          this->global_best_offset = this->local_best_offset;
                  #endif

                  if (this->debug) {
                      cerr << "[BOL] learning phase finished, winner=" << this->global_best_offset << endl;
                      cerr << this->log();
                  }
                  /* reset all internal state */
                  for (auto &entry : this->offset_list)
                      entry.score = 0;
                  this->local_best_offset = 0;
                  this->best_score = 0;
                  this->round = 0;
              }
          }
          return this->global_best_offset;
      }

      string log() {
          Table table(2, offset_list.size() + 1);
          table.set_row(0, {"Offset", "Score"});
          for (unsigned i = 0; i < offset_list.size(); i += 1) {
              table.set_cell(i + 1, 0, offset_list[i].offset);
              table.set_cell(i + 1, 1, offset_list[i].score);
          }
          return table.to_string();
      }

      void set_debug_mode(bool enable) { this->debug = enable; }

    private:
      bool is_inside_page(int page_offset) { return (0 <= page_offset && page_offset < this->blocks_in_page); }

      class Entry {
        public:
          int offset;
          int score;
      };

      int blocks_in_page;
      vector<Entry> offset_list;

      int round = 0;
      int best_score = 0;
      int index_to_test = 0;
      int local_best_offset = 0;
      int global_best_offset = 1;

      const int SCORE_MAX = 20; //默认32
      const int ROUND_MAX = 100;
      const int BAD_SCORE = 1;

      bool debug = false;
  };

  class BOP {
    public:
      //prefetchers = vector<BOP>(NUM_CPUS, BOP(PAGE_SIZE / BLOCK_SIZE, RR_TABLE_SIZE, DEGREE));
      //初始化的配置，blocks_in_page是一个页面内的blocks数目
      BOP(int blocks_in_page, int recent_requests_table_size, int degree)
          : blocks_in_page(blocks_in_page), best_offset_learning(blocks_in_page),
            recent_requests_table(recent_requests_table_size), degree(degree) {}

      /**
      * @return A vector of block numbers that should be prefetched.
      */
      vector<uint64_t> access(uint64_t block_number) {
          uint64_t page_number = block_number / this->blocks_in_page;
          int page_offset = block_number % this->blocks_in_page;
          /* ... and if X and X + D lie in the same memory page, a prefetch request for line X + D is sent to the L3
          * cache. */
          if (this->debug) {
              cerr << "[BOP] block_number=" << block_number << endl;
              cerr << "[BOP] page_number=" << page_number << endl;
              cerr << "[BOP] page_offset=" << page_offset << endl;
              cerr << "[BOP] best_offset=" << this->prefetch_offset << endl;
          }

          vector<uint64_t> pred;
          for (int i = 1; i <= this->degree; i += 1) {
              #ifdef BINGO_BOP_ON
                  if (this->prefetch_offset != 0 && is_inside_page(page_offset + i * this->prefetch_offset))
                  {
                      pred.push_back(block_number + i * this->prefetch_offset);
                  }
                  else {
                  if (this->debug)
                      cerr << "[BOP] X and X + " << i << " * D do not lie in the same memory page, no prefetch issued"
                          << endl;
                  break;
              }
              #endif
              #ifdef CP_BINGO_BOP_ON
                  if (this->prefetch_offset != 0)
                  {
                      pred.push_back(block_number + i * this->prefetch_offset);
                  }
                  else {
                      if (this->debug)
                          cerr << "[BOP] X and X + " << i << " * D do not lie in the same memory page, no prefetch issued"
                              << endl;
                      break;
                  }
              #endif
              
          }

          int old_offset = this->prefetch_offset;
          /* On every eligible L2 read access (miss or prefetched hit), we test an offset di from the list. */
          this->prefetch_offset = this->best_offset_learning.test_offset(block_number, recent_requests_table);
          if (this->debug) {
              if (old_offset != this->prefetch_offset)
                  cerr << "[BOP] offset changed from " << old_offset << " to " << this->prefetch_offset << endl;
              cerr << this->recent_requests_table.log();
              cerr << this->best_offset_learning.log();
          }
          return pred;
      }

      void cache_fill(uint64_t block_number, bool prefetch) {
          int page_offset = block_number % this->blocks_in_page;
          if (this->prefetch_offset == 0 && prefetch)
              return;
          if (this->prefetch_offset != 0 && !prefetch)
              return;
          #ifdef BINGO_BOP_ON
              if (!this->is_inside_page(page_offset - this->prefetch_offset))
                  return;
          #endif
          //当预取回来的时候，会向RR Table中插入发出预取访问的基地址
          this->recent_requests_table.insert(block_number - this->prefetch_offset);
      }

      void set_debug_level(int debug_level) {
          bool enable = (bool)debug_level;
          this->debug = enable;
          this->best_offset_learning.set_debug_mode(enable);
          this->recent_requests_table.set_debug_mode(enable);
      }

    private:
      bool is_inside_page(int page_offset) { return (0 <= page_offset && page_offset < this->blocks_in_page); }

      int blocks_in_page;
      int prefetch_offset = 0;

      BestOffsetLearning best_offset_learning;
      RecentRequestsTable recent_requests_table;
      int degree;

      bool debug = false;
  };

  vector<BOP> prefetchers;

#endif

#ifdef BERTI_PP_ON
  #define L1D_PAGE_BLOCKS_BITS (LOG2_PAGE_SIZE - LOG2_BLOCK_SIZE)
  #define L1D_PAGE_BLOCKS (1 << L1D_PAGE_BLOCKS_BITS)
  #define L1D_PAGE_OFFSET_MASK (L1D_PAGE_BLOCKS - 1)

  #define L1D_MAX_NUM_BURST_PREFETCHES 3

  #define L1D_BERTI_CTR_MED_HIGH_CONFIDENCE 2

  // To access cpu in my functions
  uint32_t l1d_cpu_id;

  // TIME AND OVERFLOWS

  #define L1D_TIME_BITS 16
  #define L1D_TIME_OVERFLOW ((uint64_t)1 << L1D_TIME_BITS)
  #define L1D_TIME_MASK (L1D_TIME_OVERFLOW - 1)

  uint64_t l1d_get_latency(uint64_t cycle, uint64_t cycle_prev) {
    return cycle - cycle_prev;
    uint64_t cycle_masked = cycle & L1D_TIME_MASK;
    uint64_t cycle_prev_masked = cycle_prev & L1D_TIME_MASK;
    if (cycle_prev_masked > cycle_masked) {
      return (cycle_masked + L1D_TIME_OVERFLOW) - cycle_prev_masked;
    }
    return cycle_masked - cycle_prev_masked;
  }

  // STRIDE

  int l1d_calculate_stride(uint64_t prev_offset, uint64_t current_offset) {
    int stride;
    if (current_offset > prev_offset) {
      stride = current_offset - prev_offset;
    } else {
      stride = prev_offset - current_offset;
      stride *= -1;
    }
    return stride;
  }

  // CURRENT PAGES TABLE

  #define L1D_CURRENT_PAGES_TABLE_INDEX_BITS 6
  #define L1D_CURRENT_PAGES_TABLE_ENTRIES ((1 << L1D_CURRENT_PAGES_TABLE_INDEX_BITS) - 1) // Null pointer for prev_request
  #define L1D_CURRENT_PAGES_TABLE_NUM_BERTI 10
  #define L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS 7

  typedef struct __l1d_current_page_entry {
    uint64_t page_addr; // 52 bits
    uint64_t ip; // 10 bits
    uint64_t u_vector; // 64 bits
    uint64_t first_offset; // 6 bits
    int berti[L1D_CURRENT_PAGES_TABLE_NUM_BERTI]; // 70 bits
    unsigned berti_ctr[L1D_CURRENT_PAGES_TABLE_NUM_BERTI]; // 60 bits
    uint64_t last_burst; // 6 bits
    uint64_t lru; // 6 bits
  } l1d_current_page_entry;
  //存放页面的访问信息
  l1d_current_page_entry l1d_current_pages_table[NUM_CPUS][L1D_CURRENT_PAGES_TABLE_ENTRIES];

  void l1d_init_current_pages_table() {
    for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
      l1d_current_pages_table[l1d_cpu_id][i].page_addr = 0;
      l1d_current_pages_table[l1d_cpu_id][i].ip = 0;
      l1d_current_pages_table[l1d_cpu_id][i].u_vector = 0; // not valid
      l1d_current_pages_table[l1d_cpu_id][i].last_burst = 0;
      l1d_current_pages_table[l1d_cpu_id][i].lru = i;
    }
  }

  uint64_t l1d_get_current_pages_entry(uint64_t page_addr) {
    for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
      if (l1d_current_pages_table[l1d_cpu_id][i].page_addr == page_addr) return i;
    }
    return L1D_CURRENT_PAGES_TABLE_ENTRIES;
  }

  void l1d_update_lru_current_pages_table(uint64_t index) {
    assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
    for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
      if (l1d_current_pages_table[l1d_cpu_id][i].lru < l1d_current_pages_table[l1d_cpu_id][index].lru) { // Found
        l1d_current_pages_table[l1d_cpu_id][i].lru++;
      }
    }
    l1d_current_pages_table[l1d_cpu_id][index].lru = 0;
  }

  uint64_t l1d_get_lru_current_pages_entry() {
    uint64_t lru = L1D_CURRENT_PAGES_TABLE_ENTRIES;
    for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
      l1d_current_pages_table[l1d_cpu_id][i].lru++;
      if (l1d_current_pages_table[l1d_cpu_id][i].lru == L1D_CURRENT_PAGES_TABLE_ENTRIES) {
        l1d_current_pages_table[l1d_cpu_id][i].lru = 0;
        lru = i;
      } 
    }
    assert(lru != L1D_CURRENT_PAGES_TABLE_ENTRIES);
    return lru;
  }

  int l1d_get_berti_current_pages_table(uint64_t index, uint64_t &ctr) {
    assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
    uint64_t max_score = 0;
    uint64_t berti = 0;
    for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
      uint64_t score; 
      score = l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i];
      if (score > max_score) {
        berti = l1d_current_pages_table[l1d_cpu_id][index].berti[i];
        max_score = score;
        ctr = l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i];
      }
    }
    return berti;
  }

  void l1d_add_current_pages_table(uint64_t index, uint64_t page_addr, uint64_t ip, uint64_t offset) {
    assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
    l1d_current_pages_table[l1d_cpu_id][index].page_addr = page_addr;
    l1d_current_pages_table[l1d_cpu_id][index].ip = ip;
    l1d_current_pages_table[l1d_cpu_id][index].u_vector = (uint64_t)1 << offset;
    l1d_current_pages_table[l1d_cpu_id][index].first_offset = offset;
    for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
      l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i] = 0;
    }
    l1d_current_pages_table[l1d_cpu_id][index].last_burst = 0;
  }

  uint64_t l1d_update_demand_current_pages_table(uint64_t index, uint64_t offset) {
    assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
    l1d_current_pages_table[l1d_cpu_id][index].u_vector |= (uint64_t)1 << offset;
    l1d_update_lru_current_pages_table(index);
    return l1d_current_pages_table[l1d_cpu_id][index].ip;
  }

  void l1d_add_berti_current_pages_table(uint64_t index, int berti) {
    assert(berti != 0);
    assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
    //这个循环里面的顺序需要调整一下，如果时按照顺序来条件新条目的话，不需要改变顺序
    for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
      if (l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i] == 0) {
        l1d_current_pages_table[l1d_cpu_id][index].berti[i] = berti;
        l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i] = 1;
        break;
      } else if (l1d_current_pages_table[l1d_cpu_id][index].berti[i] == berti) {
        l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i]++;
        break;
      }
    }
    l1d_update_lru_current_pages_table(index);
  }

  bool l1d_requested_offset_current_pages_table(uint64_t index, uint64_t offset) {
    assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
    return l1d_current_pages_table[l1d_cpu_id][index].u_vector & ((uint64_t)1 << offset);
  }

  void l1d_remove_current_table_entry(uint64_t index) {
    l1d_current_pages_table[l1d_cpu_id][index].page_addr = 0;
    l1d_current_pages_table[l1d_cpu_id][index].u_vector = 0;
    l1d_current_pages_table[l1d_cpu_id][index].berti[0] = 0;
  }

  // PREVIOUS REQUESTS TABLE

  #define L1D_PREV_REQUESTS_TABLE_INDEX_BITS 10
  #define L1D_PREV_REQUESTS_TABLE_ENTRIES (1 << L1D_PREV_REQUESTS_TABLE_INDEX_BITS)
  #define L1D_PREV_REQUESTS_TABLE_MASK (L1D_PREV_REQUESTS_TABLE_ENTRIES - 1)
  #define L1D_PREV_REQUESTS_TABLE_NULL_POINTER L1D_CURRENT_PAGES_TABLE_ENTRIES
  //页面访问时间，指针指向page——tabel中的项的索引，
  typedef struct __l1d_prev_request_entry {
    uint64_t page_addr_pointer; // 6 bits
    uint64_t offset; // 6 bits
    uint64_t time; // 16 bits
  } l1d_prev_request_entry;

  l1d_prev_request_entry l1d_prev_requests_table[NUM_CPUS][L1D_PREV_REQUESTS_TABLE_ENTRIES];
  uint64_t l1d_prev_requests_table_head[NUM_CPUS];

  void l1d_init_prev_requests_table() {
    l1d_prev_requests_table_head[l1d_cpu_id] = 0;
    for (int i = 0; i < L1D_PREV_REQUESTS_TABLE_ENTRIES; i++) {
      l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_REQUESTS_TABLE_NULL_POINTER;
    }
  }

  uint64_t l1d_find_prev_request_entry(uint64_t pointer, uint64_t offset) {
    for (int i = 0; i < L1D_PREV_REQUESTS_TABLE_ENTRIES; i++) {
      if (l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer == pointer
    && l1d_prev_requests_table[l1d_cpu_id][i].offset == offset) return i;
    }
    return L1D_PREV_REQUESTS_TABLE_ENTRIES;
  }

  void l1d_add_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
    // First find for coalescing
    if (l1d_find_prev_request_entry(pointer, offset) != L1D_PREV_REQUESTS_TABLE_ENTRIES) return;

    // Allocate a new entry (evict old one if necessary)
    l1d_prev_requests_table[l1d_cpu_id][l1d_prev_requests_table_head[l1d_cpu_id]].page_addr_pointer = pointer;
    l1d_prev_requests_table[l1d_cpu_id][l1d_prev_requests_table_head[l1d_cpu_id]].offset = offset;
    l1d_prev_requests_table[l1d_cpu_id][l1d_prev_requests_table_head[l1d_cpu_id]].time = cycle & L1D_TIME_MASK;
    l1d_prev_requests_table_head[l1d_cpu_id] = (l1d_prev_requests_table_head[l1d_cpu_id] + 1) & L1D_PREV_REQUESTS_TABLE_MASK;
  }

  void l1d_reset_pointer_prev_requests(uint64_t pointer) {
    for (int i = 0; i < L1D_PREV_REQUESTS_TABLE_ENTRIES; i++) {
      if (l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer == pointer) {
        l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_REQUESTS_TABLE_NULL_POINTER;
      }
    }
  }

  uint64_t l1d_get_latency_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
    uint64_t index = l1d_find_prev_request_entry(pointer, offset); 
    if (index == L1D_PREV_REQUESTS_TABLE_ENTRIES) return 0;
    return l1d_get_latency(cycle, l1d_prev_requests_table[l1d_cpu_id][index].time);
  }

  void l1d_get_berti_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle, int *berti) {
    int my_pos = 0;
    uint64_t extra_time = 0;
    uint64_t last_time = l1d_prev_requests_table[l1d_cpu_id][(l1d_prev_requests_table_head[l1d_cpu_id] + L1D_PREV_REQUESTS_TABLE_MASK) & L1D_PREV_REQUESTS_TABLE_MASK].time;
    for (uint64_t i = (l1d_prev_requests_table_head[l1d_cpu_id] + L1D_PREV_REQUESTS_TABLE_MASK) & L1D_PREV_REQUESTS_TABLE_MASK; i != l1d_prev_requests_table_head[l1d_cpu_id]; i = (i + L1D_PREV_REQUESTS_TABLE_MASK) & L1D_PREV_REQUESTS_TABLE_MASK) {
      // Against the time overflow
      if (last_time < l1d_prev_requests_table[l1d_cpu_id][i].time) {
        extra_time = L1D_TIME_OVERFLOW;
      }
      last_time = l1d_prev_requests_table[l1d_cpu_id][i].time;  
      if (l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer == pointer) {
        if (l1d_prev_requests_table[l1d_cpu_id][i].time <= (cycle & L1D_TIME_MASK) + extra_time) {
    berti[my_pos] = l1d_calculate_stride(l1d_prev_requests_table[l1d_cpu_id][i].offset, offset);
    my_pos++;
    if (my_pos == L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS) return;
        }
      }
    }
    berti[my_pos] = 0;
  }


  // PREVIOUS PREFETCHES TABLE

  #define L1D_PREV_PREFETCHES_TABLE_INDEX_BITS 9
  #define L1D_PREV_PREFETCHES_TABLE_ENTRIES (1 << L1D_PREV_PREFETCHES_TABLE_INDEX_BITS)
  #define L1D_PREV_PREFETCHES_TABLE_MASK (L1D_PREV_PREFETCHES_TABLE_ENTRIES - 1)
  #define L1D_PREV_PREFETCHES_TABLE_NULL_POINTER L1D_CURRENT_PAGES_TABLE_ENTRIES

  // We do not have access to the MSHR, so we aproximate it using this structure.
  //多个预取表的条目的指针可能指向同一个页的条目的索引
  typedef struct __l1d_prev_prefetch_entry {
    uint64_t page_addr_pointer; // 6 bits
    uint64_t offset; // 6 bits
    uint64_t time_lat; // 16 bits // time if not completed, latency if completed
    bool completed; // 1 bit
  } l1d_prev_prefetch_entry;

  l1d_prev_prefetch_entry l1d_prev_prefetches_table[NUM_CPUS][L1D_PREV_PREFETCHES_TABLE_ENTRIES];
  uint64_t l1d_prev_prefetches_table_head[NUM_CPUS];

  void l1d_init_prev_prefetches_table() {
    l1d_prev_prefetches_table_head[l1d_cpu_id] = 0;
    for (int i = 0; i < L1D_PREV_PREFETCHES_TABLE_ENTRIES; i++) {
      l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_PREFETCHES_TABLE_NULL_POINTER;
    }
  }

  uint64_t l1d_find_prev_prefetch_entry(uint64_t pointer, uint64_t offset) {
    for (int i = 0; i < L1D_PREV_PREFETCHES_TABLE_ENTRIES; i++) {
      if (l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer == pointer
    && l1d_prev_prefetches_table[l1d_cpu_id][i].offset == offset) return i;
    }
    return L1D_PREV_PREFETCHES_TABLE_ENTRIES;
  }

  void l1d_add_prev_prefetches_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
    // First find for coalescing
    if (l1d_find_prev_prefetch_entry(pointer, offset) != L1D_PREV_PREFETCHES_TABLE_ENTRIES) return;

    // Allocate a new entry (evict old one if necessary)
    l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].page_addr_pointer = pointer;
    l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].offset = offset;
    l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].time_lat = cycle & L1D_TIME_MASK;
    l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].completed = false;
    l1d_prev_prefetches_table_head[l1d_cpu_id] = (l1d_prev_prefetches_table_head[l1d_cpu_id] + 1) & L1D_PREV_PREFETCHES_TABLE_MASK;
  }

  void l1d_reset_pointer_prev_prefetches(uint64_t pointer) {
    for (int i = 0; i < L1D_PREV_PREFETCHES_TABLE_ENTRIES; i++) {
      if (l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer == pointer) {
        l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_PREFETCHES_TABLE_NULL_POINTER;
      }
    }
  }

  void l1d_reset_entry_prev_prefetches_table(uint64_t pointer, uint64_t offset) {
    uint64_t index = l1d_find_prev_prefetch_entry(pointer, offset);
    if (index != L1D_PREV_PREFETCHES_TABLE_ENTRIES) {
      l1d_prev_prefetches_table[l1d_cpu_id][index].page_addr_pointer = L1D_PREV_PREFETCHES_TABLE_NULL_POINTER;
    }
  }

  uint64_t l1d_get_and_set_latency_prev_prefetches_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
    uint64_t index = l1d_find_prev_prefetch_entry(pointer, offset); 
    if (index == L1D_PREV_PREFETCHES_TABLE_ENTRIES) return 0;
    if (!l1d_prev_prefetches_table[l1d_cpu_id][index].completed) {
      l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat = l1d_get_latency(cycle, l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat);
      l1d_prev_prefetches_table[l1d_cpu_id][index].completed = true;
    }    
    return l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat;
  }

  uint64_t l1d_get_latency_prev_prefetches_table(uint64_t pointer, uint64_t offset) {
    uint64_t index = l1d_find_prev_prefetch_entry(pointer, offset);
    if (index == L1D_PREV_PREFETCHES_TABLE_ENTRIES) return 0;
    if (!l1d_prev_prefetches_table[l1d_cpu_id][index].completed) return 0;
    return l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat;
  }


  // RECORD PAGES TABLE

  //#define L1D_RECORD_PAGES_TABLE_INDEX_BITS 10
  #define L1D_RECORD_PAGES_TABLE_ENTRIES (((1 << 10) + (1 << 8) + (1 << 7)) - 1) // ((1 << L1D_RECORD_PAGES_TABLE_INDEX_BITS) - 1) // Null pointer for ip table
  #define L1D_TRUNCATED_PAGE_ADDR_BITS 32 // 4 bytes
  #define L1D_TRUNCATED_PAGE_ADDR_MASK (((uint64_t)1 << L1D_TRUNCATED_PAGE_ADDR_BITS) -1)

    typedef struct __l1d_record_page_entry {
    uint64_t page_addr; // 4 bytes
    uint64_t u_vector; // 8 bytes
    uint64_t first_offset; // 6 bits
    int berti; // 7 bits
    uint64_t lru; // 10 bits
    } l1d_record_page_entry;


  l1d_record_page_entry l1d_record_pages_table[NUM_CPUS][L1D_RECORD_PAGES_TABLE_ENTRIES];

  void l1d_init_record_pages_table() {
    for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
      l1d_record_pages_table[l1d_cpu_id][i].page_addr = 0;
      l1d_record_pages_table[l1d_cpu_id][i].u_vector = 0;
      l1d_record_pages_table[l1d_cpu_id][i].lru = i;
    }
  }

  uint64_t l1d_get_lru_record_pages_entry() {
    uint64_t lru = L1D_RECORD_PAGES_TABLE_ENTRIES;
    for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
      l1d_record_pages_table[l1d_cpu_id][i].lru++;
      if (l1d_record_pages_table[l1d_cpu_id][i].lru == L1D_RECORD_PAGES_TABLE_ENTRIES) {
        l1d_record_pages_table[l1d_cpu_id][i].lru = 0;
        lru = i;
      } 
    }
    assert(lru != L1D_RECORD_PAGES_TABLE_ENTRIES);
    return lru;
  }

  void l1d_update_lru_record_pages_table(uint64_t index) {
    assert(index < L1D_RECORD_PAGES_TABLE_ENTRIES);
    for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
      if (l1d_record_pages_table[l1d_cpu_id][i].lru < l1d_record_pages_table[l1d_cpu_id][index].lru) { // Found
        l1d_record_pages_table[l1d_cpu_id][i].lru++;
      }
    }
    l1d_record_pages_table[l1d_cpu_id][index].lru = 0;
  }

  void l1d_add_record_pages_table(uint64_t index, uint64_t page_addr, uint64_t vector, uint64_t first_offset, int berti) {
    assert(index < L1D_RECORD_PAGES_TABLE_ENTRIES);
    l1d_record_pages_table[l1d_cpu_id][index].page_addr = page_addr & L1D_TRUNCATED_PAGE_ADDR_MASK;
    l1d_record_pages_table[l1d_cpu_id][index].u_vector = vector;
    l1d_record_pages_table[l1d_cpu_id][index].first_offset = first_offset;
    l1d_record_pages_table[l1d_cpu_id][index].berti = berti;    
    l1d_update_lru_record_pages_table(index);
  }

  uint64_t l1d_get_entry_record_pages_table(uint64_t page_addr, uint64_t first_offset) {
    uint64_t trunc_page_addr = page_addr & L1D_TRUNCATED_PAGE_ADDR_MASK;
    for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
      if (l1d_record_pages_table[l1d_cpu_id][i].page_addr == trunc_page_addr
    && l1d_record_pages_table[l1d_cpu_id][i].first_offset == first_offset) { // Found
        return i;
      }
    }
    return L1D_RECORD_PAGES_TABLE_ENTRIES;
  }

  uint64_t l1d_get_entry_record_pages_table(uint64_t page_addr) {
    uint64_t trunc_page_addr = page_addr & L1D_TRUNCATED_PAGE_ADDR_MASK;  
    for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
      if (l1d_record_pages_table[l1d_cpu_id][i].page_addr == trunc_page_addr) { // Found
        return i;
      }
    }
    return L1D_RECORD_PAGES_TABLE_ENTRIES;
  }

  void l1d_copy_entries_record_pages_table(uint64_t index_from, uint64_t index_to) {
    assert(index_from < L1D_RECORD_PAGES_TABLE_ENTRIES);
    assert(index_to < L1D_RECORD_PAGES_TABLE_ENTRIES);
    l1d_record_pages_table[l1d_cpu_id][index_to].page_addr = l1d_record_pages_table[l1d_cpu_id][index_from].page_addr;
    l1d_record_pages_table[l1d_cpu_id][index_to].u_vector = l1d_record_pages_table[l1d_cpu_id][index_from].u_vector;
    l1d_record_pages_table[l1d_cpu_id][index_to].first_offset = l1d_record_pages_table[l1d_cpu_id][index_from].first_offset;
    l1d_record_pages_table[l1d_cpu_id][index_to].berti = l1d_record_pages_table[l1d_cpu_id][index_from].berti;    
    l1d_update_lru_record_pages_table(index_to);
  }


  // IP TABLE

  #define L1D_IP_TABLE_INDEX_BITS 10
  #define L1D_IP_TABLE_ENTRIES (1 << L1D_IP_TABLE_INDEX_BITS)
  #define L1D_IP_TABLE_INDEX_MASK (L1D_IP_TABLE_ENTRIES - 1)
  #define L1D_IP_TABLE_NULL_POINTER L1D_RECORD_PAGES_TABLE_ENTRIES

  uint64_t l1d_ip_table[NUM_CPUS][L1D_IP_TABLE_ENTRIES]; // 11 bits

  void l1d_init_ip_table() {
    for (int i = 0; i < L1D_IP_TABLE_ENTRIES; i++) {
      l1d_ip_table[l1d_cpu_id][i] = L1D_IP_TABLE_NULL_POINTER;
    }
  }


  // TABLE MOVEMENTS

  // Sumarizes the content to the current page to be evicted
  // From all timely requests found, we record the best 
  void l1d_record_current_page(uint64_t index_current) {
    if (l1d_current_pages_table[l1d_cpu_id][index_current].u_vector) { // Valid entry
      uint64_t record_index = l1d_ip_table[l1d_cpu_id][l1d_current_pages_table[l1d_cpu_id][index_current].ip & L1D_IP_TABLE_INDEX_MASK];
      assert(record_index < L1D_RECORD_PAGES_TABLE_ENTRIES);
      uint64_t confidence;
      l1d_add_record_pages_table(record_index,
              l1d_current_pages_table[l1d_cpu_id][index_current].page_addr,
              l1d_current_pages_table[l1d_cpu_id][index_current].u_vector,
              l1d_current_pages_table[l1d_cpu_id][index_current].first_offset,
              l1d_get_berti_current_pages_table(index_current, confidence));
    }
  }

#endif

#ifdef BERTI_IP_ON
    // Last edit: 27 - Sept - 2021 12:10

    // FIFO queue
    // #define SIZE_RR 16
    // uint64_t RR[NUM_CPUS][SIZE_RR] = {0};
    // uint64_t RR_cycle[NUM_CPUS][SIZE_RR] = {0};
    // uint64_t RR_dx[NUM_CPUS] = {0};

    // how to get the pages_addr: pages_addr = (line_addr & ADDR_MASK) >> LOG2_BLOCKS_PER_PAGE
    // addr used to search latency table is w/o ADDR_MASK
    // 对于pf这一标记，用来指明是否是demand miss，但是目前的理解是针对real cache access miss和 prefetch miss时做的标记
    // 这样两个miss时，只有第一次需要进行latency计算，后续如果在cache中就不需要再继续进行latency计算了。

    void notify_prefetch(uint64_t addr, uint64_t tag, uint32_t cpu, uint64_t cycle)
    {
        latency_table_add(addr, tag, cpu, 0, cycle & TIME_MASK);
    }

    bool compare_greater_stride_t(stride_t a, stride_t b)
    {
        if (a.rpl == L1 && b.rpl != L1) return 1;
        else if (a.rpl != L1 && b.rpl == L1) return 0;
        else
        {
            if (a.rpl == L2 && b.rpl != L2) return 1;
            else if (a.rpl != L2 && b.rpl == L2) return 0;
            else
            {
                if (a.rpl == L2R && b.rpl != L2R) return 1;
                if (a.rpl != L2R && b.rpl == L2R) return 0;
                else
                {
                    if (std::abs(a.stride) < std::abs(b.stride)) return 1;
                    return 0;
                }
            }
        }
    }

    bool compare_greater_stride_t_per(stride_t a, stride_t b)
    {
        if (a.per > b.per) return 1;
        else
        {
            if (std::abs(a.stride) < std::abs(b.stride)) return 1;
            return 0;
        }
    }

    /******************************************************************************/
    /*                      Latency table functions                               */
    /******************************************************************************/
    void latency_table_init(uint32_t cpu)
    {
        /*
         * Init pqmshr (latency) table
         *
         * Parameters:
         *      - cpu: cpu
         */
        for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
        {
            latencyt[cpu][i].tag  = 0;
            latencyt[cpu][i].addr = 0;
            latencyt[cpu][i].time = 0;
            latencyt[cpu][i].pf   = 0;
        }
    }

    uint64_t latency_table_get_ip(uint64_t line_addr, uint32_t cpu)
    {
        /*
         * Return 1 or 0 if the addr is or is not in the pqmshr (latency) table
         *
         * Parameters:
         *  - line_addr: address without cache offset
         *  - cpu: actual cpu
         *
         * Return: 1 if the line is in the latency table, otherwise 0
         */

        for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
        {
            // Search if the line_addr already exists
            if (latencyt[cpu][i].addr == line_addr && latencyt[cpu][i].tag) 
                return latencyt[cpu][i].tag;
        }

        return 0;
    }

    uint8_t latency_table_add(uint64_t line_addr, uint64_t tag, uint32_t cpu, 
            uint8_t pf)
    {
        /*
         * Save if possible the new miss into the pqmshr (latency) table
         *
         * Parameters:
         *  - line_addr: address without cache offset
         *  - cpu: actual cpu
         *  - access: is the entry accessed by a demand request
         */
        return latency_table_add(line_addr, tag, cpu, pf, current_core_cycle[cpu] & TIME_MASK);
    }

    uint8_t latency_table_add(uint64_t line_addr, uint64_t tag, uint32_t cpu, 
            uint8_t pf, uint64_t cycle)
    {
        /*
         * Save if possible the new miss into the pqmshr (latency) table
         *
         * Parameters:
         *  - line_addr: address without ADDR——MASK
         *  - cpu: actual cpu
         *  - access: is theh entry accessed by a demand request
         *  - cycle: time to use in the latency table
         *
         * Return: 1 if the addr already exist, otherwise 0.
         */

        latency_table_t *free;
        free = nullptr;

        for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
        {
            // Search if the line_addr already exists. If it exist we does not have
            // to do nothing more
            if (latencyt[cpu][i].addr == line_addr) 
            {
                latencyt[cpu][i].time = cycle;
                latencyt[cpu][i].tag  = tag;
                latencyt[cpu][i].pf   = pf;
                return latencyt[cpu][i].pf;
            }

            // We discover a free space into the latency table, save it for later
            //if (latencyt[cpu][i].addr == 0) free = &latencyt[cpu][i];
            if (latencyt[cpu][i].tag == 0) free = &latencyt[cpu][i];
        }

        // No free space!! This cannot be truth
        if (free == nullptr) return 0;

        // We save the new entry into the latency table
        free->addr = line_addr;
        free->time = cycle;
        free->tag  = tag;
        free->pf   = pf;

        return free->pf;
    }

    uint64_t latency_table_del(uint64_t line_addr, uint32_t cpu)
    {
        /*
         * Remove the address from the latency table
         *
         * Parameters:
         *  - line_addr: address without cache offset
         *  - cpu: actual cpu
         *
         *  Return: the latency of the address
         */
        for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
        {
            // Line already in the table
            if (latencyt[cpu][i].addr == line_addr)
            {
                uint64_t latency = (current_core_cycle[cpu] & TIME_MASK)
                    - latencyt[cpu][i].time; // Calculate latency

                //latencyt[cpu][i].addr = 0; // Free the entry
                latencyt[cpu][i].tag  = 0; // Free the entry
                latencyt[cpu][i].time = 0; // Free the entry
                latencyt[cpu][i].pf   = 0; // Free the entry

                // Return the latency
                return latency;
            }
        }

        // We should always track the misses
        //assert(0);
        return 0;
    }

    uint64_t latency_table_get(uint64_t line_addr, uint32_t cpu)
    {
        /*
         * Return 1 or 0 if the addr is or is not in the pqmshr (latency) table
         *
         * Parameters:
         *  - line_addr: address without cache offset
         *  - cpu: actual cpu
         *
         * Return: 1 if the line is in the latency table, otherwise 0
         */

        for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
        {
            // Search if the line_addr already exists
            if (latencyt[cpu][i].addr == line_addr) return latencyt[cpu][i].time;
        }

        return 0;
    }

    /******************************************************************************/
    /*                       Shadow Cache functions                               */
    /******************************************************************************/
    void shadow_cache_init(uint32_t cpu)
    {
        /*
         * Init shadow cache
         *
         * Parameters:
         *      - cpu: cpu
         */
        for (uint8_t i = 0; i < L1D_SET; i++)
        {
            for (uint8_t ii = 0; ii < L1D_WAY; ii++)
            {
                scache[cpu][i][ii].addr = 0;
                scache[cpu][i][ii].lat  = 0;
                scache[cpu][i][ii].pf   = 0;
            }
        }
    }

    uint8_t shadow_cache_add(uint32_t cpu, uint32_t set, uint32_t way, 
            uint64_t line_addr, uint8_t pf, uint64_t latency)
    {
        /*
         * Add block to shadow cache
         *
         * Parameters:
         *      - cpu: cpu
         *      - set: cache set
         *      - way: cache way
         *      - addr: cache block v_addr
         *      - access: the cache is access by a demand
         */
        scache[cpu][set][way].addr = line_addr;
        scache[cpu][set][way].pf   = pf;
        scache[cpu][set][way].lat  = latency;
        return scache[cpu][set][way].pf;
    }

    uint8_t shadow_cache_get(uint32_t cpu, uint64_t line_addr)
    {
        /*
         * Init shadow cache
         *
         * Parameters:
         *      - cpu: cpu
         *      - addr: cache block v_addr
         *
         * Return: 1 if the addr is in the l1d cache, 0 otherwise
         */

        for (uint32_t i = 0; i < L1D_SET; i++)
        {
            for (uint32_t ii = 0; ii < L1D_WAY; ii++)
            {
                if (scache[cpu][i][ii].addr == line_addr) return 1;
            }
        }

        return 0;
    }

    uint8_t shadow_cache_pf(uint32_t cpu, uint64_t line_addr)
    {
        /*
         * Init shadow cache
         *
         * Parameters:
         *      - cpu: cpu
         *      - addr: cache block v_addr
         *
         * Return: 1 if the addr is in the l1d cache, 0 otherwise
         */

        for (uint32_t i = 0; i < L1D_SET; i++)
        {
            for (uint32_t ii = 0; ii < L1D_WAY; ii++)
            {
                if (scache[cpu][i][ii].addr == line_addr) 
                {
                    scache[cpu][i][ii].pf = 0;
                    return 1;
                }
            }
        }

        return 0;
    }

    uint8_t shadow_cache_is_pf(uint32_t cpu, uint64_t line_addr)
    {
        /*
         * Init shadow cache
         *
         * Parameters:
         *      - cpu: cpu
         *      - addr: cache block v_addr
         *
         * Return: 1 if the addr is in the l1d cache, 0 otherwise
         */

        for (uint32_t i = 0; i < L1D_SET; i++)
        {
            for (uint32_t ii = 0; ii < L1D_WAY; ii++)
            {
                if (scache[cpu][i][ii].addr == line_addr) return scache[cpu][i][ii].pf;
            }
        }

        return 0;
    }

    uint8_t shadow_cache_latency(uint32_t cpu, uint64_t line_addr)
    {
        /*
         * Init shadow cache
         *
         * Parameters:
         *      - cpu: cpu
         *      - addr: cache block v_addr
         *
         * Return: 1 if the addr is in the l1d cache, 0 otherwise
         */

        for (uint32_t i = 0; i < L1D_SET; i++)
        {
            for (uint32_t ii = 0; ii < L1D_WAY; ii++)
            {
                if (scache[cpu][i][ii].addr == line_addr) return scache[cpu][i][ii].lat;
            }
        }
        assert(0);
        return 0;
    }


    /******************************************************************************/
    /*                       History Table functions                               */
    /******************************************************************************/
    // Auxiliar history table functions
    void history_table_init(uint32_t cpu)
    {
        /*
         * Initialize history table pointers
         *
         * Parameters:
         *      - cpu: cpu
         */
        for (uint32_t i = 0; i < HISTORY_TABLE_SET; i++) 
        {
            // Pointer to the first element
            history_pointers[cpu][i] = historyt[cpu][i];

            for (uint32_t ii = 0; ii < HISTORY_TABLE_WAY; ii++) 
            {
                historyt[cpu][i][ii].tag = 0;
                historyt[cpu][i][ii].time = 0;
                historyt[cpu][i][ii].addr = 0;
            }
        }
    }

    void history_table_add(uint64_t tag, uint32_t cpu, uint64_t addr)
    {
        /*
         * Save the new information into the history table
         *
         * Parameters:
         *  - tag: PC tag
         *  - cpu: actual cpu
         *  - addr: line addr w/o ADDR_MASK
         */
        uint16_t set = tag & TABLE_SET_MASK;
        addr &= ADDR_MASK;

        uint64_t cycle = current_core_cycle[cpu] & TIME_MASK;
        // Save new element into the history table
        history_pointers[cpu][set]->tag       = tag;
        history_pointers[cpu][set]->time      = cycle;
        history_pointers[cpu][set]->addr      = addr;

        if (history_pointers[cpu][set] == &historyt[cpu][set][HISTORY_TABLE_WAY - 1])
        {
            history_pointers[cpu][set] = &historyt[cpu][set][0]; // End the cycle
        } else history_pointers[cpu][set]++; // Pointer to the next (oldest) entry
    }

    uint16_t history_table_get_aux(uint32_t cpu, uint32_t latency, 
            uint64_t tag, uint64_t act_addr, uint64_t ip[HISTORY_TABLE_WAY],
            uint64_t addr[HISTORY_TABLE_WAY], uint64_t cycle)
    {
        //**********
        //line addr with ADDR_MASK
        //**********
        uint16_t num_on_time = 0;
        uint16_t set = tag & TABLE_SET_MASK;

        // The IPs that is launch in this cycle will be able to launch this prefetch
        if (cycle < latency) return num_on_time;
        cycle -= latency; 

        // Pointer to guide
        history_table_t *pointer = history_pointers[cpu][set];

        do
        {
            // Look for the IPs that can launch this prefetch
            if (pointer->tag == tag && pointer->time <= cycle)
            {
                // Test that addr is not duplicated
                if (pointer->addr == act_addr) return num_on_time;

                int found = 0;
                for (int i = 0; i < num_on_time; i++)
                {
                    if (pointer->addr == addr[i]) return num_on_time;
                }

                // This IP can launch the prefetch
                ip[num_on_time]   = pointer->tag;
                addr[num_on_time] = pointer->addr;
                num_on_time++;
            }

            if (pointer == historyt[cpu][set])
            {
                pointer = &historyt[cpu][set][HISTORY_TABLE_WAY - 1];
            } else pointer--;
        } while (pointer != history_pointers[cpu][set]);

        return num_on_time;
    }

    uint16_t history_table_get(uint32_t cpu, uint32_t latency, 
            uint64_t tag, uint64_t act_addr,
            uint64_t ip[HISTORY_TABLE_WAY],
            uint64_t addr[HISTORY_TABLE_WAY], 
            uint64_t cycle)
    {
        /*
         * Return an array (by parameter) with all the possible PC that can launch
         * an on-time and late prefetch
         *
         * Parameters:
         *  - tag: PC tag
         *  - cpu: actual cpu
         *  - latency: latency of the processor
         *  - on_time_ip (out): ips that can launch an on-time prefetch
         *  - on_time_addr (out): addr that can launch an on-time prefetch
         *  - num_on_time (out): number of ips that can launch an on-time prefetch
         *  - addr: line addr w/o ADDR_MASK
         */

        act_addr &= ADDR_MASK;

        uint16_t num_on_time = history_table_get_aux(cpu, latency, tag, act_addr, 
                ip, addr, cycle);

        // We found on-time prefetchs
        return num_on_time;
    }


    uint16_t history_table_pages_get(uint32_t cpu, uint32_t latency, 
            uint64_t act_addr,
            uint64_t addr[HISTORY_TABLE_WAY*HISTORY_TABLE_SET], 
            uint64_t cycle)
    {
        /*
        *  - act_addr : line addr w/o ADDR_MASK
        */
        act_addr &= ADDR_MASK;
        uint16_t cur_addr = (act_addr >> LOG2_BLOCKS_PER_PAGE);

        uint16_t num_on_time = 0;

        // The IPs that is launch in this cycle will be able to launch this prefetch
        if (cycle < latency) return num_on_time;
        cycle -= latency; 

        // Pointer to guide
        for(int idx_his = 0; idx_his < HISTORY_TABLE_SET ; idx_his++)
        {
            history_table_t *pointer = history_pointers[cpu][idx_his];
            do
            {
                // Look for the IPs that can launch this prefetch
                if (pointer->time <= cycle)
                {
                    uint64_t his_addr = ((pointer->addr)>>LOG2_BLOCKS_PER_PAGE);
                    if (his_addr == cur_addr)
                    {
                        for (int i = 0; i < num_on_time; i++)
                        {
                            if (pointer->addr == addr[i]) continue;
                        }
                        addr[num_on_time] = pointer->addr;
                        num_on_time++;
                    }
                }

                if (pointer == historyt[cpu][idx_his])
                {
                    pointer = &historyt[cpu][idx_his][HISTORY_TABLE_WAY - 1];
                } else pointer--;
            } while (pointer != history_pointers[cpu][idx_his]);
        }
        return num_on_time;

        // We found on-time prefetchs
    }

    uint16_t history_table_bop_get(uint32_t cpu, uint32_t latency, 
            uint64_t act_addr,
            uint64_t timely_addr[HISTORY_TABLE_WAY*HISTORY_TABLE_SET], 
            uint64_t cycle)
    {
        /*
        *  - act_addr : line addr w/o ADDR_MASK
        */
        act_addr &= ADDR_MASK;

        uint16_t num_on_time = 0;

        // The IPs that is launch in this cycle will be able to launch this prefetch
        if (cycle < latency) return num_on_time;
        cycle -= latency; 

        // Pointer to guide
        for(int idx_his = 0; idx_his < HISTORY_TABLE_SET ; idx_his++)
        {
            history_table_t *pointer = history_pointers[cpu][idx_his];
            do
            {
                // Look for the IPs that can launch this prefetch
                if (pointer->time <= cycle)
                {
                    uint64_t his_addr = pointer->addr;
                    if (his_addr != act_addr && ((act_addr - his_addr)<256))
                    {
                        for (int i = 0; i < num_on_time; i++)
                        {
                            if (pointer->addr == timely_addr[i]) continue;
                        }
                        timely_addr[num_on_time] = pointer->addr;
                        num_on_time++;
                    }
                }

                if (pointer == historyt[cpu][idx_his])
                {
                    pointer = &historyt[cpu][idx_his][HISTORY_TABLE_WAY - 1];
                } else pointer--;
            } while (pointer != history_pointers[cpu][idx_his]);
        }
        return num_on_time;

        // We found on-time prefetchs
    }


    /******************************************************************************/
    /*                      Latency table functions                               */
    /******************************************************************************/
    // Auxiliar history table functions
    void vberti_increase_conf_ip(uint64_t tag, uint32_t cpu)
    {
        if (vbertit[cpu].find(tag) == vbertit[cpu].end()) return;

        vberti_t *tmp = vbertit[cpu][tag];
        stride_t *aux = tmp->stride;

        tmp->conf += CONFIDENCE_INC;

        if (tmp->conf == CONFIDENCE_MAX) 
        {

            // Max confidence achieve
            for(int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
            {
                float temp = (float) aux[i].conf / (float) tmp->conf;
                uint64_t aux_conf   = (uint64_t) (temp * 100);

                // Set bits
                if (aux_conf > CONFIDENCE_L1) aux[i].rpl = L1;
                else if (aux_conf > CONFIDENCE_L2) aux[i].rpl = L2;
                else if (aux_conf > CONFIDENCE_L2R) aux[i].rpl = L2R;
                else aux[i].rpl = R;
                
                aux[i].conf = 0;
            }

            tmp->conf = 0;
        }
    }

    void pages_berti_increase_conf_ip(uint64_t page_addr, uint32_t cpu)
    {
        if (pages_bertit[cpu].find(page_addr) == pages_bertit[cpu].end()) return;

        pages_berti_t *tmp = pages_bertit[cpu][page_addr];
        stride_t *aux = tmp->stride;

        tmp->conf += CONFIDENCE_INC;

        if (tmp->conf == CONFIDENCE_MAX) 
        {

            // Max confidence achieve
            for(int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
            {
                float temp = (float) aux[i].conf / (float) tmp->conf;
                uint64_t aux_conf   = (uint64_t) (temp * 100);

                // Set bits
                if (aux_conf > CONFIDENCE_L1) aux[i].rpl = L1;
                else if (aux_conf > CONFIDENCE_L2) aux[i].rpl = L2;
                else if (aux_conf > CONFIDENCE_L2R) aux[i].rpl = L2R;
                else aux[i].rpl = R;
                
                aux[i].conf = 0;
            }

            tmp->conf = 0;
        }
    }


    void vberti_table_add(uint64_t tag, uint32_t cpu, int64_t stride)
    {
        /*
         * Save the new information into the history table
         *
         * Parameters:
         *  - tag: PC tag
         *  - cpu: actual cpu
         *  - stride: actual cpu
         */
        if (vbertit[cpu].find(tag) == vbertit[cpu].end())
        {
            // FIFO MAP
            if (vbertit_queue[cpu].size() > BERTI_TABLE_SIZE)
            {
                uint64_t key = vbertit_queue[cpu].front();
                vberti_t *tmp = vbertit[cpu][key];
                delete tmp->stride;
                delete tmp;
                vbertit[cpu].erase(vbertit_queue[cpu].front());
                vbertit_queue[cpu].pop();
            }
            vbertit_queue[cpu].push(tag);

            assert(vbertit[cpu].size() <= BERTI_TABLE_SIZE);

            vberti_t *tmp = new vberti_t;
            tmp->stride = new stride_t[BERTI_TABLE_STRIDE_SIZE]();
            
            // Confidence IP
            tmp->conf = CONFIDENCE_INC;

            // Create new stride
            tmp->stride[0].stride = stride;
            tmp->stride[0].conf = CONFIDENCE_INIT;
            tmp->stride[0].rpl = R;

            // Save value
            vbertit[cpu].insert(make_pair(tag, tmp));
            return;
        }

        vberti_t *tmp = vbertit[cpu][tag];
        stride_t *aux = tmp->stride;

        // Increase IP confidence
        uint8_t max = 0;

        for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
        {
            if (aux[i].stride == stride)
            {
                aux[i].conf += CONFIDENCE_INC;
                if (aux[i].conf > CONFIDENCE_MAX) aux[i].conf = CONFIDENCE_MAX;
                return;
            }
        }

        uint8_t dx_conf = 100;
        int dx_remove = -1;
        for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
        {
            if (aux[i].rpl == R && aux[i].conf < dx_conf)
            {
                dx_conf = aux[i].conf;
                dx_remove = i;
            }
        }

        if (dx_remove > -1)
        {
            tmp->stride[dx_remove].stride = stride;
            tmp->stride[dx_remove].conf   = CONFIDENCE_INIT;
            tmp->stride[dx_remove].rpl    = R;
            return;
        } else
        {
            for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
            {
                if (aux[i].rpl == L2R && aux[i].conf < dx_conf)
                {
                    dx_conf = aux[i].conf;
                    dx_remove = i;
                }
                //if (aux[i].rpl == L2R)
                //{
                //    tmp->stride[i].stride = stride;
                //    tmp->stride[i].conf   = CONFIDENCE_INIT;
                //    tmp->stride[i].rpl    = R;
                //    return;
                //}
            }
            if (dx_remove > -1)
            {
                tmp->stride[dx_remove].stride = stride;
                tmp->stride[dx_remove].conf   = CONFIDENCE_INIT;
                tmp->stride[dx_remove].rpl    = R;
                return;
            }
        }
    }

    void pages_berti_table_add(uint64_t page_addr, uint32_t cpu, int64_t stride)
    {
        /*
         * Save the new information into the history table
         *
         * Parameters:
         *  - tag: PC tag
         *  - cpu: actual cpu
         *  - stride: actual cpu
         */
        if (pages_bertit[cpu].find(page_addr) == pages_bertit[cpu].end())
        {
            // FIFO MAP
            if (pages_bertit_queue[cpu].size() > BERTI_TABLE_SIZE)
            {
                uint64_t key = pages_bertit_queue[cpu].front();
                pages_berti_t *tmp = pages_bertit[cpu][key];
                delete tmp->stride;
                delete tmp;
                pages_bertit[cpu].erase(pages_bertit_queue[cpu].front());
                pages_bertit_queue[cpu].pop();
            }
            pages_bertit_queue[cpu].push(page_addr);

            assert(pages_bertit[cpu].size() <= BERTI_TABLE_SIZE);

            pages_berti_t *tmp = new pages_berti_t;
            tmp->stride = new stride_t[BERTI_TABLE_STRIDE_SIZE]();
            
            // Confidence IP
            tmp->conf = CONFIDENCE_INC;

            // Create new stride
            tmp->stride[0].stride = stride;
            tmp->stride[0].conf = CONFIDENCE_INIT;
            tmp->stride[0].rpl = R;

            // Save value
            pages_bertit[cpu].insert(make_pair(page_addr, tmp));
            return;
        }

        pages_berti_t *tmp = pages_bertit[cpu][page_addr];
        stride_t *aux = tmp->stride;

        // Increase IP confidence
        uint8_t max = 0;

        for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
        {
            if (aux[i].stride == stride)
            {
                aux[i].conf += CONFIDENCE_INC;
                if (aux[i].conf > CONFIDENCE_MAX) aux[i].conf = CONFIDENCE_MAX;
                return;
            }
        }

        uint8_t dx_conf = 100;
        int dx_remove = -1;
        for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
        {
            if (aux[i].rpl == R && aux[i].conf < dx_conf)
            {
                dx_conf = aux[i].conf;
                dx_remove = i;
            }
        }

        if (dx_remove > -1)
        {
            tmp->stride[dx_remove].stride = stride;
            tmp->stride[dx_remove].conf   = CONFIDENCE_INIT;
            tmp->stride[dx_remove].rpl    = R;
            return;
        } else
        {
            for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
            {
                if (aux[i].rpl == L2R && aux[i].conf < dx_conf)
                {
                    dx_conf = aux[i].conf;
                    dx_remove = i;
                }
                //if (aux[i].rpl == L2R)
                //{
                //    tmp->stride[i].stride = stride;
                //    tmp->stride[i].conf   = CONFIDENCE_INIT;
                //    tmp->stride[i].rpl    = R;
                //    return;
                //}
            }
            if (dx_remove > -1)
            {
                tmp->stride[dx_remove].stride = stride;
                tmp->stride[dx_remove].conf   = CONFIDENCE_INIT;
                tmp->stride[dx_remove].rpl    = R;
                return;
            }
        }
    }

    uint8_t vberti_table_get(uint64_t tag, uint32_t cpu, stride_t res[MAX_PF])
    {
        /*
         * Save the new information into the history table
         *
         * Parameters:
         *  - tag: PC tag
         *  - cpu: actual cpu
         *
         * Return: the stride to prefetch
         */
        if (!vbertit[cpu].count(tag)) return 0;

        vberti_t *tmp = vbertit[cpu][tag];
        stride_t *aux = tmp->stride;
        uint64_t max_conf = 0;
        uint16_t dx = 0;
        
        for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
        {
            if (aux[i].stride != 0 && aux[i].rpl)
            {
                // Substitue min confidence for the next one
                res[dx].stride = aux[i].stride;
                res[dx].rpl = aux[i].rpl;
                res[dx].conf = aux[i].conf;
                dx++;
            }
        }

        if (dx == 0 && tmp->conf >= LANZAR_INT)
        {
            for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
            {
                if (aux[i].stride != 0)
                {
                    // Substitue min confidence for the next one
                    res[dx].stride = aux[i].stride;
                    float temp = (float) aux[i].conf / (float) tmp->conf;
                    uint64_t aux_conf   = (uint64_t) (temp * 100);
                    res[dx].per = aux_conf;
                    dx++;
                }
            }
            sort(res, res + MAX_PF, compare_greater_stride_t_per);

            for (int i = 0; i < MAX_PF; i++)
            {
                if (res[i].per > 80) res[i].rpl = L1;
                else if (res[i].per > 35) res[i].rpl = L2;
                //if (res[i].per > 80) res[i].rpl = L2;
                else res[i].rpl = R;
            }
            sort(res, res + MAX_PF, compare_greater_stride_t);
            return 1;
        }

        sort(res, res + MAX_PF, compare_greater_stride_t);

        return 1;
    }


    uint8_t pages_berti_table_get(uint64_t page_addr, uint32_t cpu, stride_t res[MAX_PF])
    {
        /*
         * Save the new information into the history table
         *
         * Parameters:
         *  - page_addrt: (line_addr & ADDR_MASK) >> LOG2_BLOCKS_PER_PAGE
         *  - cpu: actual cpu
         *
         * Return: the stride to prefetch
         */
        if (!pages_bertit[cpu].count(page_addr)) return 0;

        pages_berti_t *tmp = pages_bertit[cpu][page_addr];
        stride_t *aux = tmp->stride;
        uint64_t max_conf = 0;
        uint16_t dx = 0;
        
        for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
        {
            if (aux[i].stride != 0 && aux[i].rpl)
            {
                // Substitue min confidence for the next one
                res[dx].stride = aux[i].stride;
                res[dx].rpl = aux[i].rpl;
                dx++;
            }
        }

        if (dx == 0 && tmp->conf >= LANZAR_INT)
        {
            for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
            {
                if (aux[i].stride != 0)
                {
                    // Substitue min confidence for the next one
                    res[dx].stride = aux[i].stride;
                    float temp = (float) aux[i].conf / (float) tmp->conf;
                    uint64_t aux_conf   = (uint64_t) (temp * 100);
                    res[dx].per = aux_conf;
                    dx++;
                }
            }
            sort(res, res + MAX_PF, compare_greater_stride_t_per);

            for (int i = 0; i < MAX_PF; i++)
            {
                if (res[i].per > 80) res[i].rpl = L1;
                else if (res[i].per > 35) res[i].rpl = L2;
                //if (res[i].per > 80) res[i].rpl = L2;
                else res[i].rpl = R;
            }
            sort(res, res + MAX_PF, compare_greater_stride_t);
            return 1;
        }

        sort(res, res + MAX_PF, compare_greater_stride_t);

        return 1;
    }

    void bop_deltas_table_init(uint32_t cpu)
    {
        bop_local_best_delta[cpu].score = 0;
        bop_local_best_delta[cpu].delta = 0;
        bop_global_best_delta[cpu] = 0;
        bop_pf_init_finish[cpu] = false;
        int idx = 0;
        for (int i = 1; i < 256; i += 1)
        {
            int n = i;
            for (int j = 2; j <= 5; j += 1)
            {
                while (n % j == 0)
                {
                    n /= j;
                }
            }
            if (n == 1)
            {
                bop_deltas_table[cpu][idx].delta=i;
                bop_deltas_table[cpu][idx].score=0;
                idx++;
            }       
        }

    }

    void bop_deltas_table_update(uint32_t cpu, int64_t delta)
    {
        bool phase_end = false;
        for(int i = 0; i < BOP_DELTAS_NUM; i++)
        {
            bop_delta_entry &a = bop_deltas_table[cpu][i];
            if(a.delta == delta)
            {
                a.score++;
            }
            if(a.score > bop_local_best_delta[cpu].score)
            {
                bop_local_best_delta[cpu] = a;
            }
            if(a.score == BOP_MAX_SCORE)
            {
                phase_end = true;
            }
        }
        bop_learning_round[cpu]++;
        if(phase_end == true && bop_learning_round[cpu] == BOP_MAX_ROUND)
        {
            bop_pf_init_finish[cpu]=true;
            for(int i = 0; i < BOP_DELTAS_NUM; i++)
            {
                bop_delta_entry &b = bop_deltas_table[cpu][i];
                b.score = 0;
            }
            bop_global_best_delta[cpu] = bop_local_best_delta[cpu].delta;
        }
    }

    void find_and_update(uint32_t cpu, uint64_t latency, uint64_t tag, 
            uint64_t cycle, uint64_t line_addr)
    { 
        //************
        //line addr : line addr w/o ADDR_MASK

        //***************
        // We were tracking this miss
        uint64_t ip[HISTORY_TABLE_WAY];
        uint64_t addr[HISTORY_TABLE_WAY];
        uint16_t num_on_time = 0;

      #ifdef BERTI_IP_ON
        // Get the IPs that can launch a prefetch
        num_on_time = history_table_get(cpu, latency, tag, line_addr, ip, addr, cycle);
            //***********************ip*****************************//
        for (uint32_t i = 0; i < num_on_time; i++)
        {
            // Increase conf ip
            if (i == 0) vberti_increase_conf_ip(tag, cpu);
            
            // Max number of strides that we can find
            if (i >= MAX_HISTORY_IP) break;

            // Add information into berti table
            int64_t stride;
            line_addr &= ADDR_MASK;

            // Usually applications go from lower to higher memory position.
            // The operation order is important (mainly because we allow
            // negative strides)
            stride = (int64_t) (line_addr - addr[i]);

            if ((std::abs(stride) < (1 << STRIDE_MASK)))
            {
                // Only useful strides
                vberti_table_add(ip[i], cpu, stride);
                //根据这里tag的获取方式，可以得知，这几个stride的ip也即tag是完全一样的
            }
        }
        #endif

        #ifdef BERTI_PAGES_ON
        uint16_t pages_num_on_time = 0;
        uint64_t pages_addr[HISTORY_TABLE_SET*HISTORY_TABLE_WAY];
        pages_num_on_time = history_table_pages_get(cpu, latency, line_addr, pages_addr, cycle);
        //***********************pages*****************************//
        //access cache的时候还是需要更新pages_bertit的，只不过是在预取的时候，如果没有ip匹配的，那就使用pages_bertit
        for(uint32_t i = 0; i < pages_num_on_time ; i++)
        {
            if(i == 0) pages_berti_increase_conf_ip(((line_addr&ADDR_MASK)>>LOG2_BLOCKS_PER_PAGE),cpu);
            //if(i == 0) pages_berti_increase_conf_ip((line_addr>>LOG2_BLOCKS_PER_PAGE),cpu);
            if (i >= MAX_HISTORY_IP) break;

            // Add information into berti table
            int64_t stride;
            //line_addr &= ADDR_MASK;

            // Usually applications go from lower to higher memory position.
            // The operation order is important (mainly because we allow
            // negative strides)
            stride = (int64_t) ((ADDR_MASK&line_addr)- pages_addr[i]);

            if ((std::abs(stride) < (1 << STRIDE_MASK)))
            {
                // Only useful strides
                pages_berti_table_add(((line_addr&ADDR_MASK)>>LOG2_BLOCKS_PER_PAGE), cpu, stride);
                //pages_berti_table_add((line_addr>>LOG2_BLOCKS_PER_PAGE), cpu, stride);
            }
        }
        #else
        #endif

        #ifdef BOP_ON
        uint16_t bop_num_on_time;
        uint64_t timely_addr[HISTORY_TABLE_SET*HISTORY_TABLE_WAY];
        bop_num_on_time = history_table_bop_get(cpu, latency, line_addr, timely_addr, cycle);

        //***********************bop*****************************//
        for(uint32_t i = 0; i < bop_num_on_time ; i++)
        {
            int64_t delta = (line_addr & ADDR_MASK)-timely_addr[i];
            bop_deltas_table_update(cpu, delta);
        }
        #endif

    }
#endif

void CACHE::l1d_prefetcher_initialize() 
{   
    #ifdef BERTI_IP_ON
        shadow_cache_init(cpu);
        latency_table_init(cpu);
        history_table_init(cpu);
    #endif
    #ifdef BERTI_PP_ON
        l1d_cpu_id = cpu;
        l1d_init_current_pages_table();
        l1d_init_prev_requests_table();
        l1d_init_prev_prefetches_table();
        l1d_init_record_pages_table();
        l1d_init_ip_table();
    #endif
    #ifdef BOP_ON
        bop_deltas_table_init(cpu);
    #endif
    #ifdef BINGO_BOP_ON
        prefetchers = vector<BOP>(NUM_CPUS, BOP((1 << LOG2_BLOCKS_PER_PAGE), RR_TABLE_SIZE, DEGREE));
    #endif
    // std::cout << "History Sets: " << HISTORY_TABLE_SET << std::endl;
    // std::cout << "History Ways: " << HISTORY_TABLE_WAY << std::endl;
    // std::cout << "BERTI Size: " << BERTI_TABLE_SIZE << std::endl;
    // std::cout << "BERTI Stride Size: " << BERTI_TABLE_STRIDE_SIZE << std::endl;
    #ifdef BINGO
        /*=== Bingo Settings ===*/
        const int REGION_SIZE = 2 * 1024;  /* size of spatial region = 2KB */
        const int PC_WIDTH = 16;           /* number of PC bits used in PHT */
        const int MIN_ADDR_WIDTH = 5;      /* number of Address bits used for PC+Offset matching */
        const int MAX_ADDR_WIDTH = 16;     /* number of Address bits used for PC+Address matching */
        const int FT_SIZE = 64;            /* size of filter table */
        const int AT_SIZE = 128;           /* size of accumulation table */
        const int PHT_SIZE = SIZE_OF_PHT; //1024 * 8;     /* size of pattern history table (PHT) */	//EDIT BY Neelu, 6 instead of 8.
        const int PHT_WAYS = WAYS_IN_PHT; //16;           /* associativity of PHT */ 	Neelu: Assoc. 12 for 6*1024 entries.
        const int PF_STREAMER_SIZE = 128;  /* size of prefetch streamer */
        /*======================*/

        /* number of PHT sets must be a power of 2 */
        // assert(__builtin_popcount(PHT_SIZE / PHT_WAYS) == 1);

        /* construct prefetcher for all cores */
        // assert(PAGE_SIZE % REGION_SIZE == 0);
        L1D_PREF::prefetchers = vector<L1D_PREF::Bingo>(
            NUM_CPUS, L1D_PREF::Bingo(REGION_SIZE >> LOG2_BLOCK_SIZE, MIN_ADDR_WIDTH, MAX_ADDR_WIDTH, PC_WIDTH, FT_SIZE,
                            AT_SIZE, PHT_SIZE, PHT_WAYS, PF_STREAMER_SIZE, L1D_PREF::DEBUG_LEVEL));

    #endif
    #ifdef MLOP_ON
        /*=== MLOP Settings ===*/
        const int BLOCKS_IN_CACHE = CACHE::NUM_SET * CACHE::NUM_WAY;
        const int BLOCKS_IN_ZONE = PAGE_SIZE / BLOCK_SIZE;
        const int AMT_SIZE = 32 * BLOCKS_IN_CACHE / BLOCKS_IN_ZONE; /* size of access map table */

        /* maximum possible prefetch degree (the actual prefetch degree is usually much smaller) */
        const int PREFETCH_DEGREE = 16;

        /* number of score updates before selecting prefetch offsets (thus, it is also the maximum possible score) */
        const int NUM_UPDATES = 500;

        /* prefetch offsets with `score >= LX_THRESH * NUM_UPDATES` into LX */
        const double L1D_THRESH = 0.40; 
        const double L2C_THRESH = 0.30;
        const double LLC_THRESH = 2.00; /* off */
        /*======================*/

        /* construct prefetcher for all cores */
        L1D_PREF_2::prefetchers =
            vector<L1D_PREF_2::MLOP>(NUM_CPUS, L1D_PREF_2::MLOP(BLOCKS_IN_ZONE, AMT_SIZE, PREFETCH_DEGREE, NUM_UPDATES,
                                                L1D_THRESH, L2C_THRESH, LLC_THRESH, L1D_PREF_2::DEBUG_LEVEL));
    #endif
    
}

#ifdef MEMORY_ACCESS_PATTERN_DEBUG
void CACHE::l1d_prefetcher_operate(uint64_t addr,uint64_t physical_addr, uint64_t ip, uint8_t cache_hit,
        uint8_t type, uint8_t critical_ip_flag)
#else
void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit,
        uint8_t type, uint8_t critical_ip_flag)
#endif
{ 
    #ifdef MEMORY_ACCESS_PATTERN_DEBUG
        bool trigger_miss = false;
    #endif
    //assert(type == LOAD || type == RFO);  
    uint64_t line_addr = (addr >> LOG2_BLOCK_SIZE); // Line addr  
    uint64_t pc = ip;
    ip = ((ip >> 1) ^ (ip >> 4));
    //ip = (ip >> 1) ^ (ip >> 4) ^ (ip >> 8);
    ip = ip & IP_MASK;

    

    #ifdef BINGO_BOP_ON
        bool bingo_bop_triger = false;      
    #endif

    #ifdef BERTI_IP_TABLE_DEBUG
        bool trigger_miss = false;
        if(warmup_complete[cpu] == 1)
        {
            std::cout << "pc:"<<pc <<" "<<"ip:"<<ip<<" ";
            std::cout << "offset:"<<(line_addr%(1<<LOG2_BLOCKS_PER_PAGE))<<" ";
            std::cout << "baddr:"<< line_addr<<" ";
            std::cout << "vpaddr:"<< (line_addr >> LOG2_BLOCKS_PER_PAGE)<<" ";

        }
    #endif

    #ifdef BERTI_IP_ON
        if (!cache_hit)
        {
            #ifdef BERTI_IP_TABLE_DEBUG
            if(warmup_complete[cpu] == 1)
            {
                std::cout << "M" <<std::endl;
                trigger_miss = true;
            }
            #endif
            #ifdef MEMORY_ACCESS_PATTERN_DEBUG
                trigger_miss = true;
            #endif
            // This is a miss
        
            // Add @ to latency table
            latency_table_add(line_addr, ip, cpu, 1);

            // Add to history table
            history_table_add(ip, cpu, line_addr);
            if(RECORD_IP_ADDR)
            {
                std::cout << "cache miss" << std::endl;
            }
            #ifdef BINGO_BOP_ON
                bingo_bop_triger = true;
            #endif
            #ifdef MLOP_ON
                L1D_PREF_2::prefetchers[cpu].access(line_addr);
            #endif

        } 
        else if (cache_hit && shadow_cache_is_pf(cpu, line_addr))
        {
            #ifdef BERTI_IP_TABLE_DEBUG
            if(warmup_complete[cpu] == 1)
            {
                std::cout << "PH" <<std::endl;
            }
                trigger_miss = true;
            #endif
            #ifdef MEMORY_ACCESS_PATTERN_DEBUG
                trigger_miss = true;
                
            #endif
            if(RECORD_IP_ADDR)
            {
                std::cout << "cache hit && is pf" << std::endl;
            }
            // Cache line access
            shadow_cache_pf(cpu, line_addr);

            // Buscar strides Y actualizar
            uint64_t latency = shadow_cache_latency(cpu, line_addr);
            find_and_update(cpu, latency, ip, current_core_cycle[cpu] & TIME_MASK, 
                    line_addr);

            history_table_add(ip, cpu, line_addr); 
            #ifdef BINGO_BOP_ON
                bingo_bop_triger = true;
            #endif

            #ifdef MLOP_ON
                L1D_PREF_2::prefetchers[cpu].access(line_addr);
            #endif
        } 
        else
        {
            #ifdef BERTI_IP_TABLE_DEBUG
                if(warmup_complete[cpu] == 1)
                {
                    std::cout << "H" <<std::endl;
                }
            #endif
            // Cache line access
            shadow_cache_pf(cpu, line_addr);
            // No pf in hit
            //return;
        }
    #endif

    #ifdef BERTI_IP_TABLE_DEBUG
        if(trigger_miss && warmup_complete[cpu]==1)
        {
            //print_latency_table(cpu);
            //print_history_table(cpu);
            //print_stride_table(cpu);
        }
    #endif

    #ifdef MEMORY_ACCESS_PATTERN_DEBUG
      //这里的地址应该为物理地址，因为用来索引cache了
      //full_addr为虚拟地址，full_physical_address为物理地址，address为虚拟的块地址
      //uint64_t line_addr_debug = (RQ.entry[RQ.head].full_addr >> LOG2_BLOCK_SIZE); // Line addr  
      uint64_t line_addr_debug = (physical_addr >> LOG2_BLOCK_SIZE);//物理地址
      uint64_t page_addr_debug = (line_addr_debug >> LOG2_BLOCKS_PER_PAGE);
      uint64_t page_addr_offset = (line_addr_debug %(1 << LOG2_BLOCKS_PER_PAGE));
      if(cache_type == IS_L1D && (type == RFO || type == LOAD) && (warmup_complete[cpu]==1) && trigger_miss)
      {
          // std::cout<<RQ.entry[index].ip << ' '<<page_addr_debug << ' '<<page_addr_offset<<' '<<line_addr_debug << std::endl;
          // std::cout << RQ.entry[RQ.head].address << " "<< RQ.entry[RQ.head].full_addr <<std::endl;
          // std::cout << (RQ.entry[RQ.head].full_addr >> LOG2_BLOCK_SIZE) << std::endl;
          act_ValuePair value;
          value.offset = page_addr_offset;
          value.ppaddr = page_addr_debug;
          value.vpaddr = line_addr >> LOG2_BLOCKS_PER_PAGE;
          // std::cout<<(RQ.entry[RQ.head].full_addr >> LOG2_BLOCK_SIZE)<< " "<<line_addr_debug<< std::endl;
          // std::cout << RQ.entry[index].address<< std::endl;
          insertEntry(act_dict,pc,value);
      }
    #endif



    #ifdef BERTI_PP_ON
      l1d_cpu_id = cpu;
      ip = pc;
      uint64_t page_addr = line_addr >> L1D_PAGE_BLOCKS_BITS;
      uint64_t offset = line_addr & L1D_PAGE_OFFSET_MASK;
      // Update current pages table
      // Find the entry
      //可以认为pages table是按照内容进行索引的，返回页地址相同的那一个条目的索引
      uint64_t index = l1d_get_current_pages_entry(page_addr);

      // If not accessed recently
      //如果没有这个页的信息，或者当前页的访问偏移在之前没有出现过，那么就为其添加条目
      if (index == L1D_CURRENT_PAGES_TABLE_ENTRIES
          || !l1d_requested_offset_current_pages_table(index, offset)) 
      {
        //有页信息但是没有offset
        //cout << "OFFSETS: " << hex << ip << " " << page_addr << " " << dec << offset << endl;

        //这种情况是是新的offset,这种情况说明当前访问是hot page,还不是cold page，没有页需要被剔除到
        //recorded tabel中，也就是这个页之前被访问过
        if (index < L1D_CURRENT_PAGES_TABLE_ENTRIES) 
        { // Found
          //cout << " FOUND" << endl;

          // If offset found, already requested, so return;
          if (l1d_requested_offset_current_pages_table(index, offset)) return;

          //更新对应条目的offset向量，更新所有pages条目的lru优先级，并且返回第一次访问这个page的ip地址
          uint64_t first_ip = l1d_update_demand_current_pages_table(index, offset);

          //l1d_ip_table中记录这个ip指向的pages——table的条目的索引，因为这是个hot page
          assert(l1d_ip_table[l1d_cpu_id][first_ip & L1D_IP_TABLE_INDEX_MASK] != L1D_IP_TABLE_NULL_POINTER);

          // Update berti
          //确认是预取回来的块，并且已经获得了预取这个块回来所需要的时间，那么就可以获得及时
          //访问回来得到的delta
          if (cache_hit) 
          {
            //在预取表中查找当前是否是预取的块，如果是并且已经预取完成了，那么就可以获得取回这个数据所需要的时间
            uint64_t pref_latency = l1d_get_latency_prev_prefetches_table(index, offset);

            //确认是预取回来的块，并且已经获得了预取这个块回来所需要的时间，那么就可以获得及时
            //访问回来得到的delta
            if (pref_latency != 0) 
            {
              // Find berti distance from pref_latency cycles before
              int berti[L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS]; 

              l1d_get_berti_prev_requests_table(index, offset, current_core_cycle[cpu] - pref_latency, berti);
              for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS; i++) 
              {
                if (berti[i] == 0) break; 
                assert(abs(berti[i]) < L1D_PAGE_BLOCKS);

                //更新或者加入每一个delta的得分
                l1d_add_berti_current_pages_table(index, berti[i]);
              }

              // Eliminate a prev prefetch since it has been used
              //可以消除预取表中这一项了，因为已经统计过信息，使用完成了，相当于预取命中了
              l1d_reset_entry_prev_prefetches_table(index, offset);
            }  
          }

          //如果第一次访问这个页的ip与当前访问这个页的ip不同
          if (first_ip != ip) 
          {
            // Assign same pointer to group IPs
            //所有访问同一个页的ip表的指针都等于访问这个页的第一个ip指向记录表的指针
            //这个与前面的预取并不矛盾
            l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = l1d_ip_table[l1d_cpu_id][first_ip & L1D_IP_TABLE_INDEX_MASK]; 
          }
        }
        //如果这次访问的是一个冷页，主要是将页驱逐，并且为新页分配一个ip table的指针
        else 
        { 
          //没有页信息，第一次访问一个页
          // Not found: Add entry
        
          // Find victim and clear pointers to it
          uint64_t victim_index = l1d_get_lru_current_pages_entry(); // already updates lru
          assert(victim_index < L1D_CURRENT_PAGES_TABLE_ENTRIES);

          //所有指向被驱逐的页的条目的指针都要被置为无效
          l1d_reset_pointer_prev_requests(victim_index); // Not valid anymore
          l1d_reset_pointer_prev_prefetches(victim_index); // Not valid anymore

          //将被剔除的页面的信息放入到record表中
          // Copy victim to record table
          //在record中的索引已经早已分配好，由表项中的第一次访问的页的ip来确定
          //在将current table中的页分配给record table中的页时，需要将offset vector，以及得分最大的
          //offset以及offset对应的得分都传递给record表,但是offset的得分没有用到
          l1d_record_current_page(victim_index);

          // Add new current page
          index = victim_index;
          l1d_add_current_pages_table(index, page_addr, ip & L1D_IP_TABLE_INDEX_MASK, offset);

          // Set pointer in IP table
          //对于一个cold page,在record表中查找是否有对应的条目,因为page在currrent table中
          //的存在是有生命周期的，所以很有可能recorded table中还存在有对应的条目
          //同一个page在record table中可能有多个项，因为访问的offset不同
          uint64_t index_record = l1d_get_entry_record_pages_table(page_addr, offset);
          // The ip pointer is null
          //如果访问这个当前的冷页的第一个ip在ip table中没有索引
          //这种情况下又分了record table中是否有对应的条目来讨论
          if (l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] == L1D_IP_TABLE_NULL_POINTER) 
          { 
            //在表中没有ip没有record，也就是这个指针和页面都没有出现过
            //那么就为其在record表中分配一个新的条目，并且将ip 表中的ip对应的指针指向record table的项
            if (index_record == L1D_RECORD_PAGES_TABLE_ENTRIES) 
            { // Page not recorded
              // Get free record page pointer.
              uint64_t new_pointer = l1d_get_lru_record_pages_entry();
              l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = new_pointer;
            }
            //如果这个ip不存在，但是这个页在record table中存在，说明上一次访问这个页的第一个ip和当前的ip不同
            //就将只需要将现在的ip也指向record table中的那个页
            else 
            {
              l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = index_record;
            }
          } 
          //这种情况是，ip table中有索引（同一个ip但是访问的是其他页），但是record table中没有索引，
          //或者record table中有索引，但是指向的不是同一个页，这种也是同一个ip但是访问的是其他页
          else if (l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] != index_record) 
          {
            // If the current IP is valid, but points to another address
            // we replicate it in another record entry (lru)
            // such that the recorded page is not deleted when the current entry summarizes
            //由于是新页，所以需要重新分配一个页
            uint64_t new_pointer = l1d_get_lru_record_pages_entry();
            //并且将ip对应的页的信息先赋给这个新页，并且更新ip的指针，为这个新页的地址
            l1d_copy_entries_record_pages_table(l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK], new_pointer);
            l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = new_pointer;
          }
        }

        //记录访问的信息表
        l1d_add_prev_requests_table(index, offset, current_core_cycle[cpu]);
          
        // PREDICT
        uint64_t u_vector = 0;
        //first是当前访问的hot page的第一个偏移
        uint64_t first_offset = l1d_current_pages_table[l1d_cpu_id][index].first_offset;
        int berti = 0;
        bool recorded = false;
        
        //分别找到三种匹配，ip 匹配，ip通常与page联系在一起，但是找到的是record page的索引，或者没有
        //pgo是page和offset的索引，所以找的是，当前页和页的第一个offset都满足的record page的索引
        //pg是page的索引，找的是page的索引
        uint64_t ip_pointer = l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK];
        uint64_t pgo_pointer = l1d_get_entry_record_pages_table(page_addr, first_offset);
        uint64_t pg_pointer = l1d_get_entry_record_pages_table(page_addr);
        uint64_t berti_confidence = 0;
        int current_berti = l1d_get_berti_current_pages_table(index, berti_confidence);
        uint64_t match_confidence = 0;
        
        // If match with current page+first_offset, use record
        //如果page和起始的offset都匹配，并且当前在这个页的访问轨迹和之前record table中记录的访问轨迹完全一致
        //这种属于高度匹配
        if (pgo_pointer != L1D_RECORD_PAGES_TABLE_ENTRIES
          && (l1d_record_pages_table[l1d_cpu_id][pgo_pointer].u_vector | l1d_current_pages_table[l1d_cpu_id][index].u_vector) == l1d_record_pages_table[l1d_cpu_id][pgo_pointer].u_vector) 
        {
          u_vector =  l1d_record_pages_table[l1d_cpu_id][pgo_pointer].u_vector;
          berti =  l1d_record_pages_table[l1d_cpu_id][pgo_pointer].berti;
          match_confidence = 1; // High confidence
          recorded = true;
        } 
        else
        // If match with current ip+first_offset, use record
        //如果当前ip访问的页的偏移，与这个ip之前访问的页的偏移相同，而且页内的访问轨迹也相同
        if (l1d_record_pages_table[l1d_cpu_id][ip_pointer].first_offset == first_offset
          && (l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector | l1d_current_pages_table[l1d_cpu_id][index].u_vector) == l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector) 
        {
          u_vector =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector;
          berti =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].berti;
          match_confidence = 1; // High confidence
          recorded = true;
        } else
        // If no exact match, trust current if it has already a berti
        //如果没有匹配的，但是有分数比较高的delta,那么就用当前这个hot page的信息，并且只选择一个得分最高的delta
        if (current_berti != 0 && berti_confidence >= L1D_BERTI_CTR_MED_HIGH_CONFIDENCE) 
        { // Medium-High confidence
          u_vector =  l1d_current_pages_table[l1d_cpu_id][index].u_vector;
          berti = current_berti;
        } else
        // If match with current page, use record
        //如果当前hot page没有合适的，但是有这个页之前的信息
        if (pg_pointer != L1D_RECORD_PAGES_TABLE_ENTRIES) 
        { // Medium confidence
          u_vector =  l1d_record_pages_table[l1d_cpu_id][pg_pointer].u_vector;
          berti =  l1d_record_pages_table[l1d_cpu_id][pg_pointer].berti;
          recorded = true;
        } else
        // If match with current ip, use record
        //这个ip应该会指向这个页，所以这个循环应该是进不去的？
        if (l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector) 
        { // Medium confidence
          u_vector =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector;
          berti =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].berti;
          recorded = true;
        }

        // Burst for the first access of a page or if pending bursts
        //如果当前是对一个hot page的第一次访问，或者是上一次突发结束的不为0，说明需要突发
        if (first_offset == offset || l1d_current_pages_table[l1d_cpu_id][index].last_burst != 0) 
        {
          uint64_t first_burst;
          if (l1d_current_pages_table[l1d_cpu_id][index].last_burst != 0) 
          {
            first_burst = l1d_current_pages_table[l1d_cpu_id][index].last_burst;
            l1d_current_pages_table[l1d_cpu_id][index].last_burst = 0;
          } 
          else if (berti >= 0) 
          {
            first_burst = offset + 1;
          }	
          else 
          {
            first_burst = offset - 1;
          }


          if (recorded && match_confidence) 
          {
            int bursts = 0;
            if (berti > 0) 
            {
              for (uint64_t i = first_burst; i < offset+berti; i++) 
              {
                if (i >= L1D_PAGE_BLOCKS) break; // Stay in the page
                // Only if previously requested and not demanded
                uint64_t pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | i;
                uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
                uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
                //l1d_requested_offset_current_pages_table这个hot page最近有没有这个pf_offset的请求
                if ((((uint64_t)1 << i) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset)) 
                {
                  if ((PQ.occupancy + mix_deltas.size())< PQ.SIZE && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
                  {
                    //只要PQ.occupancy < PQ.SIZE,那么prefetched就会为真
                    #ifdef MIX_DELTA
                        mix_delta new_delta = {pf_addr,ip,FILL_L1,{0},index,8};
                        mergeDelta(mix_deltas,new_delta);
                        bursts++;
                        //std::cout << "PP: " << ip<<" "<<addr<<" "<<pf_addr<<" "<<std::endl;
                    #else
                        bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
                        if (prefetched) 
                        {
                        assert(pf_page_addr == page_addr);
                        l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
                        bursts++;
                        }
                    #endif
                    
                  } 
                  //如过发不完就记住当前的地址，下一次继续发
                  else 
                  { // record last burst
                    l1d_current_pages_table[l1d_cpu_id][index].last_burst = i;
                    break;
                  }
                }
              }
            } 
            else if (berti < 0) 
            {
              for (int i = first_burst; i > ((int)offset)+berti; i--) 
              {
                if (i < 0) break; // Stay in the page
                // Only if previously requested and not demanded
                uint64_t pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | i;
                uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
                uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
                if ((((uint64_t)1 << i) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset)) 
                {
                  if ((PQ.occupancy + mix_deltas.size()) && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
                  {
                    #ifdef MIX_DELTA
                        mix_delta new_delta = {pf_addr,ip,FILL_L1,{0},index,8};
                        mergeDelta(mix_deltas,new_delta);
                        bursts++;
                        //std::cout << "PP: " << ip<<" "<<addr<<" "<<pf_addr<<" "<<std::endl;
                    #else
                        bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
                        if (prefetched) 
                        {
                        assert(pf_page_addr == page_addr);
                        l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
                        bursts++;
                        }
                    #endif
                    
                  } 
                  else 
                  { // record last burst
                    l1d_current_pages_table[l1d_cpu_id][index].last_burst = i;
                    break;
                  }
                }
              }
            } 
            else 
            { // berti == 0 (zig zag of all)
              for (int i = first_burst, j = (first_offset << 1) - i;
              i < L1D_PAGE_BLOCKS || j >= 0; i++, j = (first_offset << 1) - i) 
              {
                // Only if previously requested and not demanded
                // Dir ++
                uint64_t pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | i;
                uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
                uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
                if ((((uint64_t)1 << i) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset) && (i < L1D_PAGE_BLOCKS)) 
                {
                  if ((PQ.occupancy + mix_deltas.size()) && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
                  {
                    #ifdef MIX_DELTA
                        mix_delta new_delta = {pf_addr,ip,FILL_L1,{0},index,8};
                        mergeDelta(mix_deltas,new_delta);
                        bursts++;
                        //std::cout << "PP: " << ip<<" "<<addr<<" "<<pf_addr<<" "<<std::endl;
                    #else
                        bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
                        if (prefetched) 
                        {
                        assert(pf_page_addr == page_addr);
                        l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
                        bursts++;
                        }
                    #endif
                    
                  } 
                  else 
                  { // record last burst
                    l1d_current_pages_table[l1d_cpu_id][index].last_burst = i;
                    break;
                  }
                }
                // Dir --
                pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | j;
                pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
                pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
                pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
                if ((((uint64_t)1 << j) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset)&&(j>0)&&(j<L1D_PAGE_BLOCKS)) 
                {
                  if ((PQ.occupancy + mix_deltas.size()) && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
                  {
                    #ifdef MIX_DELTA
                        mix_delta new_delta = {pf_addr,ip,FILL_L1,{0},index,8};
                        mergeDelta(mix_deltas,new_delta);
                        bursts++;
                        //std::cout << "PP: " << ip<<" "<<addr<<" "<<pf_addr<<" "<<std::endl;
                    #else
                        bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
                        if (prefetched) 
                        {
                        assert(pf_page_addr == page_addr);
                        l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
                        bursts++;
                        }
                    #endif
                    
                  } else 
                  {
                    // record only positive burst
                  }
                }
              }
            }  
          } 
          else 
          { // not recorded
          }	
        }
          
        if (berti != 0) 
        {
          uint64_t pf_line_addr = line_addr + berti;
          uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
          uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
          uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
          if (!l1d_requested_offset_current_pages_table(index, pf_offset) // Only prefetch if not demanded
            && (!match_confidence || (((uint64_t)1 << pf_offset) & u_vector))&&(pf_page_addr == page_addr)) 
          { // And prev. accessed
            #ifdef MIX_DELTA
                mix_delta new_delta = {pf_addr,ip,FILL_L1,{1},index,8};
                mergeDelta(mix_deltas,new_delta);
                //std::cout << "PP: " << ip<<" "<<addr<<" "<<pf_addr<<" "<<std::endl;
            #else
                bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
                if (prefetched) 
                {
                assert(pf_page_addr == page_addr);
                l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
                }
            #endif
            
          }
        }
      } 
    #endif

    #ifdef BERTI_IP_ON
        #ifdef BERTI_PP_ON
            ip = ((ip >> 1) ^ (ip >> 4));
            //ip = (ip >> 1) ^ (ip >> 4) ^ (ip >> 8);
            ip = ip & IP_MASK;
            // Get stride to prefetch
        #endif
        stride_t stride[MAX_PF];
        for (int i = 0; i < MAX_PF; i++) 
        {
            stride[i].conf = 0;
            stride[i].stride = 0;
            stride[i].rpl = R;
        }

        //******************IP prefetch**************
        if(RECORD_IP_ADDR)
        {
            std::cout << "PC is:"<< pc << " IP is: "<< ip <<" ADDR is:"<< addr << std::endl;
            std::cout << "IP hex is:"<< std::hex << ip <<" Line ADDR is:"<< std::hex << line_addr << std::dec << std::endl;
            std::cout << "Pages Addr is:"<< std::hex << ((line_addr&ADDR_MASK)>>LOG2_BLOCKS_PER_PAGE) << std::dec << std::endl;
        }
        int launched_ip = 0;
        #ifdef MIX_DELTA
            mix_delta new_delta = {((line_addr + 1) << LOG2_BLOCK_SIZE),ip,FILL_L1,{2},0,9};
            mergeDelta(mix_deltas,new_delta);
            //std::cout << "IP: " << ip<<" "<<addr<<" "<<((line_addr + 1) << LOG2_BLOCK_SIZE)<<" "<<std::endl;
        #else
            bool prefetched = prefetch_line(ip, addr, (line_addr + 1) << LOG2_BLOCK_SIZE, FILL_L1, 1);
        #endif
        if(!vberti_table_get(ip, cpu, stride))
        {
        }
        else
        {
            uint32_t count = 0;
            for (int i = 0; i < MAX_PF_LAUNCH; i++)
            {

                uint64_t p_addr = (line_addr + stride[i].stride) << LOG2_BLOCK_SIZE;
                uint64_t p_b_addr = (p_addr >> LOG2_BLOCK_SIZE);
                
                //if (!shadow_cache_get(cpu, p_b_addr)
                if (!latency_table_get(p_addr, cpu))
                {
                    
                    int fill_level = FILL_L1;
                    float mshr_load = ((float) MSHR.occupancy / (float) MSHR_SIZE) * 100;
                    #ifdef BOP_DEBUG
                        std::cout << "IP MSHR: "<< mshr_load <<"sconf: " << stride[i].conf << "stride: "<< stride[i].stride <<std::endl;
                    #endif

                    // Level of prefetching depends son CONFIDENCE
                    if (stride[i].rpl == L1 && mshr_load < MSHR_LIMIT)
                    {
                        #ifdef RECORD_DELTAS
                            std::cout << stride[i].stride << " ";
                        #endif                  
                        fill_level = FILL_L1;
                        
                        #ifdef MIX_DELTA
                            if(stride[i].stride != 0)
                            {
                                mix_delta new_delta = {p_addr, ip,fill_level,{3},0,stride[i].conf};
                                mergeDelta(mix_deltas,new_delta);
                                //std::cout << "IP: " << ip<<" "<<addr<<" "<<p_addr<<" "<<std::endl;
                            }
                        #endif
                    } else if (stride[i].rpl == L1 || stride[i].rpl == L2 
                            || stride[i].rpl == L2R ){
                        #ifdef RECORD_DELTAS
                            std::cout << stride[i].stride << " ";
                        #endif                   
                        fill_level = FILL_L2;
                        #ifdef MIX_DELTA
                            if(stride[i].stride != 0)
                            {
                                mix_delta new_delta = {p_addr, ip,fill_level,{3},0,stride[i].conf};
                                mergeDelta(mix_deltas,new_delta);
                                //std::cout << "IP: " << ip<<" "<<addr<<" "<<p_addr<<" "<<std::endl;
                            }
                        #endif
                    } else
                    {
                        //return;
                        break;
                    }
                    
                    
                    #ifdef  MIX_DELTA
                    #else
                        //0b01:IP
                        #ifdef PREFETCHER_CLASS_DEBUG
                        uint32_t pf_metadata_encode_ip = metadata_encode(1,0b01);
                            if (prefetch_line(ip, addr, p_addr, fill_level, pf_metadata_encode_ip))
                        #else
                            if (prefetch_line(ip, addr, p_addr, fill_level,1))
                        #endif
                        {
                            launched_ip++;
                        }
                    #endif
                }
            }
            #ifdef BOP_DEBUG
                std::cout << "IP NUMS: "<< launched_ip <<std::endl;
            #endif
        }
    #endif  

    #ifdef BINGO_BOP_ON
        int launched_bop = 0;
            if(bingo_bop_triger == true)
            {
                /* call prefetcher and send prefetches */
                //prefetchers是BOP类的一个数组，在CACHE初始化的时候同时进行初始化
                vector<uint64_t> to_prefetch = prefetchers[cpu].access(line_addr);
                for (auto &pf_block_number : to_prefetch) {
                    uint64_t pf_address = pf_block_number << LOG2_BLOCK_SIZE;
                    #ifdef MIX_DELTA
                        mix_delta new_delta = {pf_address, ip,FILL_L1,{4},0,1};
                        mergeDelta(mix_deltas,new_delta);
                    #else
                        prefetch_line(ip, addr, pf_address, FILL_L1,1);
                    #endif
                    // /* champsim automatically ignores prefetches that cross page boundaries */
                    // float mshr_load = ((float) MSHR.occupancy / (float) MSHR_SIZE) * 100;
                    // #ifdef BOP_DEBUG
                    //     std::cout << "BOP L1 " << "MSHR: " << mshr_load <<std::endl;
                    // #endif
                    // //0b11:bop
                    // #ifdef PREFETCHER_CLASS_DEBUG
                    // uint32_t pf_metadata_encode_bop = metadata_encode(1,0b11);
                    // #endif
                    // if (!latency_table_get(pf_address, cpu)){
                        
                    //     if((mshr_load < (MSHR_LIMIT + 10)) && ((launched_ip + launched_pages)< MAX_PF_LAUNCH))
                    //     {   
                    //         #ifdef PREFETCHER_CLASS_DEBUG
                    //         prefetch_line(ip, addr, pf_address, FILL_L1,pf_metadata_encode_bop);
                    //         #else
                    //         prefetch_line(ip, addr, pf_address, FILL_L1,1);
                    //         #endif
                    //     }
                    //     else
                    //     {
                    //         #ifdef PREFETCHER_CLASS_DEBUG
                    //         prefetch_line(ip, addr, pf_address, FILL_L1,pf_metadata_encode_bop);
                    //         #else
                    //         prefetch_line(ip, addr, pf_address, FILL_L1,1);
                    //         #endif
                    //     }
                    //     launched_bop++;
                    // }               
                }
            }
            #ifdef BOP_DEBUG
                std::cout << "BOP NUMS " << launched_bop <<std::endl;
            #endif
    #endif
    #ifdef MIX_DELTA
        // std::cout << mix_deltas.size() <<std::endl;
        std::sort(mix_deltas.begin(), mix_deltas.end(), compare_delta_scores);
        int count = 0;
        int fill_level = 0;
        for (const mix_delta &elem : mix_deltas) 
        {
            int64_t delta = int64_t((elem.pf_addr)>>LOG2_BLOCK_SIZE)- int64_t(line_addr);
            // std::cout <<elem.ip<<" "<<addr <<" "<<elem.pf_addr<<" ";
            // std::cout <<elem.fill_level<<" "<<elem.prefetcher<<" ";
            // std::cout <<elem.berti_pp_index<<" " << elem.score<<std::endl;
            switch(elem.fill_level)
            {
                case(R):{fill_level = 0; break;}
                case(L1):{fill_level = 1; break;}
                case(L2):{fill_level = 2; break;}
                case(L2R):{fill_level = 3; break;}
            }
            if((elem.prefetcher == 0 || elem.prefetcher == 1))
            {   
                bool prefetched = prefetch_line(elem.ip, addr, elem.pf_addr, elem.fill_level, 0);
                if(prefetched)
                {
                    l1d_add_prev_prefetches_table(elem.berti_pp_index, ((elem.pf_addr)>>LOG2_BLOCK_SIZE)&L1D_PAGE_OFFSET_MASK, current_core_cycle[cpu]);
                }              
            }
            else if(elem.prefetcher == 2)
            {
                bool prefetched = prefetch_line(elem.ip, addr, elem.pf_addr, elem.fill_level, 1);
            }
            #ifdef BERTI_IP_TABLE_DEBUG           
                if(warmup_complete[cpu] == 1)
                {
                    count++;
                    std::cout <<"["<< delta << " "<<((elem.pf_addr)>>LOG2_BLOCK_SIZE) << " "<<fill_level<<" {";
                    for(int pref: elem.prefetcher)
                    {
                        std::cout<<pref << " ";
                    }
                    std::cout<<"}" <<"]";
                    if(count == 6)
                    {
                        count = 0;
                        std::cout << std::endl;
                    }
                }
            #endif
        }
        // std::cout << "round_end" <<std::endl;
        mix_deltas.clear();
        #ifdef BERTI_IP_TABLE_DEBUG
            if(warmup_complete[cpu]==1)
            {
                if(count!=0)
                {
                    std::cout << std::endl;
                }
            }
        #endif
    #endif
    
    //std::cout << float(PQ.occupancy) << " " << float(MSHR.occupancy) << std::endl;

    #ifdef BINGO
        if(warmup_complete[cpu] && warmup_flag_l1 == 0)
        {
            L1D_PREF::prefetchers[cpu].reset_stats();
            warmup_flag_l1 = 1;
        }
        

        if (L1D_PREF::DEBUG_LEVEL >= 2) {
            cerr << "CACHE::l1d_prefetcher_operate(addr=0x" << hex << addr << ", ip=0x" << ip << ", cache_hit=" << dec
                << (int)cache_hit << ", type=" << (int)type << ")" << dec << endl;
            cerr << "[CACHE::l1d_prefetcher_operate] CACHE{core=" << this->cpu << ", NAME=" << this->NAME << "}" << dec
                << endl;
        }


        uint64_t block_number = addr >> LOG2_BLOCK_SIZE;

        /* update BINGO with most recent LOAD access */
        L1D_PREF::prefetchers[cpu].access(block_number, pc);

        /* issue prefetches */
        L1D_PREF::prefetchers[cpu].prefetch(this, block_number);

        if (L1D_PREF::DEBUG_LEVEL >= 3) {
            L1D_PREF::prefetchers[cpu].log();
            cerr << "=======================================" << dec << endl;
        }
    #endif

    #ifdef BERTI_PAGES_ON
        for (int i = 0; i < MAX_PF; i++) 
        {
            stride[i].conf = 0;
            stride[i].stride = 0;
            stride[i].rpl = R;
        }
        int launched_pages = 0;
        //*********************pages prefetch*********************//
        if (!pages_berti_table_get(((line_addr&ADDR_MASK)>>LOG2_BLOCKS_PER_PAGE), cpu, stride)) 
        {
            if(RECORD_DELTAS)
            {
                std::cout << "Pages berti deltas no found" << std::endl;
            }
        }
        else
        {        
            if(RECORD_DELTAS)
            {
                std::cout << "Pages berti deltas:" << std::endl;
            }
            for (int i = 0; i < MAX_PF_LAUNCH; i++)
            {
                uint64_t p_addr = (line_addr + stride[i].stride) << LOG2_BLOCK_SIZE;
                uint64_t p_b_addr = (p_addr >> LOG2_BLOCK_SIZE);

                if (!latency_table_get(p_addr, cpu))
                {

                    int fill_level = FILL_L1;
                    float mshr_load = ((float) MSHR.occupancy / (float) MSHR_SIZE) * 100;
                    #ifdef BOP_DEBUG
                        std::cout << "PAGES MSHR: "<< mshr_load <<"sconf: " << stride[i].conf << "stride: "<< stride[i].stride <<std::endl;
                    #endif

                    // Level of prefetching depends son CONFIDENCE
                    if (stride[i].rpl == L1 && mshr_load < MSHR_LIMIT)
                    {
                        fill_level = FILL_L1;
                        #ifdef BERTI_IP_TABLE_DEBUG
                            std::cout << "deltas:"<< stride[i].stride << " L1" << " pref_addr:" <<std::hex << p_b_addr << std::dec<< std::endl;
                        #endif
                    } else if (stride[i].rpl == L1 || stride[i].rpl == L2 
                            || stride[i].rpl == L2R ){
                        fill_level = FILL_L2;
                        #ifdef BERTI_IP_TABLE_DEBUG
                            std::cout << "deltas:"<< stride[i].stride << " L2" << " pref_addr:"<<std::hex << p_b_addr << std::dec<< std::endl;
                        #endif
                    } else
                    {
                        //return;
                        break;
                    }

                    //0b10:Pages
                    #ifdef PREFETCHER_CLASS_DEBUG
                    uint32_t pf_metadata_encode_pages = metadata_encode(1,0b10);
                    
                    if (prefetch_line(ip, addr, p_addr, fill_level, pf_metadata_encode_pages))
                    #else
                        if (prefetch_line(ip, addr, p_addr, fill_level, 1))
                    #endif
                    {
                        if(RECORD_DELTAS)
                        {
                            std::cout << "prefetch"<< std::endl;
                        }
                        launched_pages++;
                    }
                }

            }
            #ifdef BOP_DEBUG
                std::cout << "PAGES NUMS: "<< launched_pages <<std::endl;
            #endif
        }
    #endif

    #ifdef BOP_ON
        int launched_bop = 0;
        //***************bop prefetch******************//
        if(bop_pf_init_finish[cpu] == true)
        {
            uint64_t p_addr = (line_addr + bop_global_best_delta[cpu]) << LOG2_BLOCK_SIZE;
            uint64_t p_b_addr = (p_addr >> LOG2_BLOCK_SIZE);
            if (prefetch_line(ip, addr, p_addr, FILL_L1, 1))
            {
                launched++;
            }
        }
    #endif

    


    #ifdef MLOP_ON
        L1D_PREF_2::prefetchers[cpu].mark(line_addr, L1D_PREF_2::State::ACCESS);
        L1D_PREF_2::prefetchers[cpu].prefetch(this, line_addr);
        L1D_PREF_2::prefetchers[cpu].track(line_addr);
    #endif

    
    return;
}

void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, 
        uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, 
        uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, 
        uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, 
        uint64_t evicted_addr, uint32_t metadata_in)
{

    
    #ifdef BERTI_IP_ON
    uint64_t line_addr = (v_addr >> LOG2_BLOCK_SIZE); // Line addr
      uint64_t line_evicted = (v_evicted_addr >> LOG2_BLOCK_SIZE); // Line addr

      // Remove @ from latency table
      uint64_t tag     = latency_table_get_ip(line_addr, cpu);
      uint64_t cycle   = latency_table_get(line_addr, cpu);
      uint64_t latency = latency_table_del(line_addr, cpu);

      if (latency > LAT_MASK) latency = 0;

      // Add to the shadow cache
      shadow_cache_add(cpu, set, way, line_addr, prefetch, latency);

      if (latency != 0 && !prefetch)
      {
          find_and_update(cpu, latency, tag, cycle, line_addr);
      }
    #endif

    #ifdef BINGO
        if(this->block[set][way].valid != 0)
        {
            for (int i = 0; i < NUM_CPUS; i += 1)
                L1D_PREF::prefetchers[i].eviction(line_evicted);
        }
    #endif
    #ifdef BINGO_BOP_ON
        prefetchers[cpu].cache_fill(line_addr, (bool)prefetch);
    #endif

    #ifdef BERTI_PP_ON
      l1d_cpu_id = cpu;
      //这个地方源代码可能有问题，用
      //uint64_t line_addr = (addr >> LOG2_BLOCK_SIZE);应该是v_addr
      #ifndef BERTI_IP_ON
        uint64_t line_addr = (v_addr >> LOG2_BLOCK_SIZE);
      #endif 
      
      uint64_t page_addr = line_addr >> L1D_PAGE_BLOCKS_BITS;
      uint64_t offset = line_addr & L1D_PAGE_OFFSET_MASK;
      uint64_t pointer_prev = l1d_get_current_pages_entry(page_addr);
  
      if (pointer_prev < L1D_CURRENT_PAGES_TABLE_ENTRIES) { // Not found, not entry in prev requests
        uint64_t pref_latency = l1d_get_and_set_latency_prev_prefetches_table(pointer_prev, offset, current_core_cycle[cpu]);
        uint64_t demand_latency = l1d_get_latency_prev_requests_table(pointer_prev, offset, current_core_cycle[cpu]);
        
        // First look in prefetcher, since if there is a hit, it is the time the miss started
        // If no prefetch, then its latency is the demand one
        if (pref_latency == 0) {
          pref_latency = demand_latency;
        }     
        
        if (demand_latency != 0) { // Not found, berti will not be found neither
          
          // Find berti (distance from pref_latency + demand_latency cycles before
          int berti[L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS]; 
          l1d_get_berti_prev_requests_table(pointer_prev, offset, current_core_cycle[cpu] - (pref_latency + demand_latency), berti);
          for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS; i++) {
      if (berti[i] == 0) break;
      assert(abs(berti[i]) < L1D_PAGE_BLOCKS);
      l1d_add_berti_current_pages_table(pointer_prev, berti[i]);
          }
        }
      }

      uint64_t victim_index = l1d_get_current_pages_entry(evicted_addr >> LOG2_PAGE_SIZE);
      if (victim_index < L1D_CURRENT_PAGES_TABLE_ENTRIES) {
        // Copy victim to record table
        l1d_record_current_page(victim_index);
        l1d_remove_current_table_entry(victim_index);
      }
    #endif
}

void CACHE::l1d_prefetcher_final_stats()
{
    #ifdef BINGO
        L1D_PREF::prefetchers[cpu].print_stats();
    #endif
}


#ifdef PREFETCHER_CLASS_DEBUG
  //对应的decode版本定义在cache.cc和cache.h中
  //metadata[8:7]来做标记：01：IP， 10：Pages 11：bop
    uint32_t metadata_encode(uint32_t metadata_origin, uint32_t prefetcher_type)
    {
        uint32_t mask = ~(0b11 << 7); // 屏蔽位，位8和位7为0，其它位为1
        uint32_t setting = (prefetcher_type & 0b11) << 7; // 设定值，位8和位7为你所需要的值，其它位为0
        return (metadata_origin & mask) | setting; // 清除位8和位7并设置为新值
    }
#endif

#ifdef BERTI_IP_TABLE_DEBUG
  void print_latency_table(uint32_t cpu)
  {
      uint32_t count = 0;
      std::cout << "latency" << std::endl;
      for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
      {
          //以addr的内容进行匹配
          if(latencyt[cpu][i].tag != 0)
          {
              std::cout << i <<":" <<" " ;
              std::cout << "{"<<latencyt[cpu][i].addr << " ";
              std::cout << latencyt[cpu][i].time << " ";
              std::cout << latencyt[cpu][i].tag << " " ;
              if(!latencyt[cpu][i].pf)
              {
                  std::cout << "0" ;  
              }else{
                  std::cout << "1" ;
              }
              std::cout <<"}";
              if(count == 6){
                  count = 0;
                  std::cout << std::endl;
              }
              count++;
          }
      }
  }
  void print_history_table(uint32_t cpu)
  {
      
      std::cout << "history" << std::endl;
      for (uint32_t set = 0; set< HISTORY_TABLE_SET; set++)
      {
          uint32_t count = 0;
          bool start = false;
          history_table_t *pointer = history_pointers[cpu][set];
          do
          { 
              if(pointer->tag != 0)
              {
                  if(!start){
                      std::cout << "set"<< set <<": ";
                      start = true;
                  }
                  std::cout <<"{"<< pointer->tag <<" ";
                  std::cout << pointer->addr <<" ";
                  std::cout << pointer->time <<"}";
                  if(count == 6){
                      count = 0;
                      std::cout << std::endl;
                  }
                  count++;
              }

              if (pointer == historyt[cpu][set])
              {
                  pointer = &historyt[cpu][set][HISTORY_TABLE_WAY - 1];
              } else pointer--;
          } while (pointer != history_pointers[cpu][set]);
          std::cout << std::endl;
      }
  }

  void print_stride_table(uint32_t cpu)
  {
      std::cout << "stride" << std::endl;
      //stride的map的key就是tag
      std::queue<uint64_t> tag_fifo;
      tag_fifo = vbertit_queue[cpu];
      while (!tag_fifo.empty()) 
      {   
          uint32_t count = 0;
          uint64_t tag = tag_fifo.front();
          std::cout <<"tag:" << tag << " ";
          tag_fifo.pop();
          vberti_t *tmp = vbertit[cpu][tag];
          std::cout << tmp->conf << " ";
          std::cout << tmp->total_used;
          stride_t *strides = tmp->stride;
          for (int i = 0; i < BERTI_TABLE_STRIDE_SIZE; i++)
          {
              if(strides[i].conf != 0)
              {
                  std::cout <<"{"<<strides[i].stride <<" ";
                  std::cout << strides[i].conf << " "; //置信度
                  switch(strides[i].rpl)
                  {
                      case L1:
                      {
                          std::cout << "L1";//根据strides[i].conf/strides.conf置信度来判断放到哪个级别的cache中
                          break;
                      }
                      case L2:
                      {
                          std::cout << "L2";//根据strides[i].conf/strides.conf置信度来判断放到哪个级别的cache中
                          break;
                      }
                      case L2R:
                      {
                          std::cout << "L2R";//根据strides[i].conf/strides.conf置信度来判断放到哪个级别的cache中
                          break;
                      }
                      case R:
                      {
                          std::cout << "R" ;//根据strides[i].conf/strides.conf置信度来判断放到哪个级别的cache中
                          break;
                      }
                  }
                  std::cout << "}";
                  if(count == 6){
                      count = 0;
                      std::cout << std::endl;
                  }
                  count++;
              }
          }
          std::cout <<std::endl;
      }

  }
#endif

//-----------------------------------------------------------------------------------------------------------------------
// // Code submitted for the Third Data Prefetching Championship
// //
// // Author: Alberto Ros, University of Murcia
// //
// // Paper #13: Berti: A Per-Page Best-Request-Time Delta Prefetcher

// #include "cache.h"

// #define L1D_PAGE_BLOCKS_BITS (LOG2_PAGE_SIZE - LOG2_BLOCK_SIZE)
// #define L1D_PAGE_BLOCKS (1 << L1D_PAGE_BLOCKS_BITS)
// #define L1D_PAGE_OFFSET_MASK (L1D_PAGE_BLOCKS - 1)

// #define L1D_MAX_NUM_BURST_PREFETCHES 3

// #define L1D_BERTI_CTR_MED_HIGH_CONFIDENCE 2

// // To access cpu in my functions
// uint32_t l1d_cpu_id;

// // TIME AND OVERFLOWS

// #define L1D_TIME_BITS 16
// #define L1D_TIME_OVERFLOW ((uint64_t)1 << L1D_TIME_BITS)
// #define L1D_TIME_MASK (L1D_TIME_OVERFLOW - 1)

// uint64_t l1d_get_latency(uint64_t cycle, uint64_t cycle_prev) {
//   return cycle - cycle_prev;
//   uint64_t cycle_masked = cycle & L1D_TIME_MASK;
//   uint64_t cycle_prev_masked = cycle_prev & L1D_TIME_MASK;
//   if (cycle_prev_masked > cycle_masked) {
//     return (cycle_masked + L1D_TIME_OVERFLOW) - cycle_prev_masked;
//   }
//   return cycle_masked - cycle_prev_masked;
// }

// // STRIDE

// int l1d_calculate_stride(uint64_t prev_offset, uint64_t current_offset) {
//   int stride;
//   if (current_offset > prev_offset) {
//     stride = current_offset - prev_offset;
//   } else {
//     stride = prev_offset - current_offset;
//     stride *= -1;
//   }
//   return stride;
// }

// // CURRENT PAGES TABLE

// #define L1D_CURRENT_PAGES_TABLE_INDEX_BITS 6
// #define L1D_CURRENT_PAGES_TABLE_ENTRIES ((1 << L1D_CURRENT_PAGES_TABLE_INDEX_BITS) - 1) // Null pointer for prev_request
// #define L1D_CURRENT_PAGES_TABLE_NUM_BERTI 10
// #define L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS 7

// typedef struct __l1d_current_page_entry {
//   uint64_t page_addr; // 52 bits
//   uint64_t ip; // 10 bits
//   uint64_t u_vector; // 64 bits
//   uint64_t first_offset; // 6 bits
//   int berti[L1D_CURRENT_PAGES_TABLE_NUM_BERTI]; // 70 bits
//   unsigned berti_ctr[L1D_CURRENT_PAGES_TABLE_NUM_BERTI]; // 60 bits
//   uint64_t last_burst; // 6 bits
//   uint64_t lru; // 6 bits
// } l1d_current_page_entry;
// //存放页面的访问信息
// l1d_current_page_entry l1d_current_pages_table[NUM_CPUS][L1D_CURRENT_PAGES_TABLE_ENTRIES];

// void l1d_init_current_pages_table() {
//   for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
//     l1d_current_pages_table[l1d_cpu_id][i].page_addr = 0;
//     l1d_current_pages_table[l1d_cpu_id][i].ip = 0;
//     l1d_current_pages_table[l1d_cpu_id][i].u_vector = 0; // not valid
//     l1d_current_pages_table[l1d_cpu_id][i].last_burst = 0;
//     l1d_current_pages_table[l1d_cpu_id][i].lru = i;
//   }
// }

// uint64_t l1d_get_current_pages_entry(uint64_t page_addr) {
//   for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
//     if (l1d_current_pages_table[l1d_cpu_id][i].page_addr == page_addr) return i;
//   }
//   return L1D_CURRENT_PAGES_TABLE_ENTRIES;
// }

// void l1d_update_lru_current_pages_table(uint64_t index) {
//   assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
//   for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
//     if (l1d_current_pages_table[l1d_cpu_id][i].lru < l1d_current_pages_table[l1d_cpu_id][index].lru) { // Found
//       l1d_current_pages_table[l1d_cpu_id][i].lru++;
//     }
//   }
//   l1d_current_pages_table[l1d_cpu_id][index].lru = 0;
// }

// uint64_t l1d_get_lru_current_pages_entry() {
//   uint64_t lru = L1D_CURRENT_PAGES_TABLE_ENTRIES;
//   for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_ENTRIES; i++) {
//     l1d_current_pages_table[l1d_cpu_id][i].lru++;
//     if (l1d_current_pages_table[l1d_cpu_id][i].lru == L1D_CURRENT_PAGES_TABLE_ENTRIES) {
//       l1d_current_pages_table[l1d_cpu_id][i].lru = 0;
//       lru = i;
//     } 
//   }
//   assert(lru != L1D_CURRENT_PAGES_TABLE_ENTRIES);
//   return lru;
// }

// int l1d_get_berti_current_pages_table(uint64_t index, uint64_t &ctr) {
//   assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
//   uint64_t max_score = 0;
//   uint64_t berti = 0;
//   for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
//     uint64_t score; 
//     score = l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i];
//     if (score > max_score) {
//       berti = l1d_current_pages_table[l1d_cpu_id][index].berti[i];
//       max_score = score;
//       ctr = l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i];
//     }
//   }
//   return berti;
// }

// void l1d_add_current_pages_table(uint64_t index, uint64_t page_addr, uint64_t ip, uint64_t offset) {
//   assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
//   l1d_current_pages_table[l1d_cpu_id][index].page_addr = page_addr;
//   l1d_current_pages_table[l1d_cpu_id][index].ip = ip;
//   l1d_current_pages_table[l1d_cpu_id][index].u_vector = (uint64_t)1 << offset;
//   l1d_current_pages_table[l1d_cpu_id][index].first_offset = offset;
//   for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
//     l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i] = 0;
//   }
//   l1d_current_pages_table[l1d_cpu_id][index].last_burst = 0;
// }

// uint64_t l1d_update_demand_current_pages_table(uint64_t index, uint64_t offset) {
//   assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
//   l1d_current_pages_table[l1d_cpu_id][index].u_vector |= (uint64_t)1 << offset;
//   l1d_update_lru_current_pages_table(index);
//   return l1d_current_pages_table[l1d_cpu_id][index].ip;
// }

// void l1d_add_berti_current_pages_table(uint64_t index, int berti) {
//   assert(berti != 0);
//   assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
//   //这个循环里面的顺序需要调整一下，如果时按照顺序来条件新条目的话，不需要改变顺序
//   for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI; i++) {
//     if (l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i] == 0) {
//       l1d_current_pages_table[l1d_cpu_id][index].berti[i] = berti;
//       l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i] = 1;
//       break;
//     } else if (l1d_current_pages_table[l1d_cpu_id][index].berti[i] == berti) {
//       l1d_current_pages_table[l1d_cpu_id][index].berti_ctr[i]++;
//       break;
//     }
//   }
//   l1d_update_lru_current_pages_table(index);
// }

// bool l1d_requested_offset_current_pages_table(uint64_t index, uint64_t offset) {
//   assert(index < L1D_CURRENT_PAGES_TABLE_ENTRIES);
//   return l1d_current_pages_table[l1d_cpu_id][index].u_vector & ((uint64_t)1 << offset);
// }

// void l1d_remove_current_table_entry(uint64_t index) {
//   l1d_current_pages_table[l1d_cpu_id][index].page_addr = 0;
//   l1d_current_pages_table[l1d_cpu_id][index].u_vector = 0;
//   l1d_current_pages_table[l1d_cpu_id][index].berti[0] = 0;
// }

// // PREVIOUS REQUESTS TABLE

// #define L1D_PREV_REQUESTS_TABLE_INDEX_BITS 10
// #define L1D_PREV_REQUESTS_TABLE_ENTRIES (1 << L1D_PREV_REQUESTS_TABLE_INDEX_BITS)
// #define L1D_PREV_REQUESTS_TABLE_MASK (L1D_PREV_REQUESTS_TABLE_ENTRIES - 1)
// #define L1D_PREV_REQUESTS_TABLE_NULL_POINTER L1D_CURRENT_PAGES_TABLE_ENTRIES
// //页面访问时间，指针指向page——tabel中的项的索引，
// typedef struct __l1d_prev_request_entry {
//   uint64_t page_addr_pointer; // 6 bits
//   uint64_t offset; // 6 bits
//   uint64_t time; // 16 bits
// } l1d_prev_request_entry;

// l1d_prev_request_entry l1d_prev_requests_table[NUM_CPUS][L1D_PREV_REQUESTS_TABLE_ENTRIES];
// uint64_t l1d_prev_requests_table_head[NUM_CPUS];

// void l1d_init_prev_requests_table() {
//   l1d_prev_requests_table_head[l1d_cpu_id] = 0;
//   for (int i = 0; i < L1D_PREV_REQUESTS_TABLE_ENTRIES; i++) {
//     l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_REQUESTS_TABLE_NULL_POINTER;
//   }
// }

// uint64_t l1d_find_prev_request_entry(uint64_t pointer, uint64_t offset) {
//   for (int i = 0; i < L1D_PREV_REQUESTS_TABLE_ENTRIES; i++) {
//     if (l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer == pointer
// 	&& l1d_prev_requests_table[l1d_cpu_id][i].offset == offset) return i;
//   }
//   return L1D_PREV_REQUESTS_TABLE_ENTRIES;
// }

// void l1d_add_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
//   // First find for coalescing
//   if (l1d_find_prev_request_entry(pointer, offset) != L1D_PREV_REQUESTS_TABLE_ENTRIES) return;

//   // Allocate a new entry (evict old one if necessary)
//   l1d_prev_requests_table[l1d_cpu_id][l1d_prev_requests_table_head[l1d_cpu_id]].page_addr_pointer = pointer;
//   l1d_prev_requests_table[l1d_cpu_id][l1d_prev_requests_table_head[l1d_cpu_id]].offset = offset;
//   l1d_prev_requests_table[l1d_cpu_id][l1d_prev_requests_table_head[l1d_cpu_id]].time = cycle & L1D_TIME_MASK;
//   l1d_prev_requests_table_head[l1d_cpu_id] = (l1d_prev_requests_table_head[l1d_cpu_id] + 1) & L1D_PREV_REQUESTS_TABLE_MASK;
// }

// void l1d_reset_pointer_prev_requests(uint64_t pointer) {
//   for (int i = 0; i < L1D_PREV_REQUESTS_TABLE_ENTRIES; i++) {
//     if (l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer == pointer) {
//       l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_REQUESTS_TABLE_NULL_POINTER;
//     }
//   }
// }

// uint64_t l1d_get_latency_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
//   uint64_t index = l1d_find_prev_request_entry(pointer, offset); 
//   if (index == L1D_PREV_REQUESTS_TABLE_ENTRIES) return 0;
//   return l1d_get_latency(cycle, l1d_prev_requests_table[l1d_cpu_id][index].time);
// }

// void l1d_get_berti_prev_requests_table(uint64_t pointer, uint64_t offset, uint64_t cycle, int *berti) {
//   int my_pos = 0;
//   uint64_t extra_time = 0;
//   uint64_t last_time = l1d_prev_requests_table[l1d_cpu_id][(l1d_prev_requests_table_head[l1d_cpu_id] + L1D_PREV_REQUESTS_TABLE_MASK) & L1D_PREV_REQUESTS_TABLE_MASK].time;
//   for (uint64_t i = (l1d_prev_requests_table_head[l1d_cpu_id] + L1D_PREV_REQUESTS_TABLE_MASK) & L1D_PREV_REQUESTS_TABLE_MASK; i != l1d_prev_requests_table_head[l1d_cpu_id]; i = (i + L1D_PREV_REQUESTS_TABLE_MASK) & L1D_PREV_REQUESTS_TABLE_MASK) {
//     // Against the time overflow
//     if (last_time < l1d_prev_requests_table[l1d_cpu_id][i].time) {
//       extra_time = L1D_TIME_OVERFLOW;
//     }
//     last_time = l1d_prev_requests_table[l1d_cpu_id][i].time;  
//     if (l1d_prev_requests_table[l1d_cpu_id][i].page_addr_pointer == pointer) {
//       if (l1d_prev_requests_table[l1d_cpu_id][i].time <= (cycle & L1D_TIME_MASK) + extra_time) {
// 	berti[my_pos] = l1d_calculate_stride(l1d_prev_requests_table[l1d_cpu_id][i].offset, offset);
// 	my_pos++;
// 	if (my_pos == L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS) return;
//       }
//     }
//   }
//   berti[my_pos] = 0;
// }


// // PREVIOUS PREFETCHES TABLE

// #define L1D_PREV_PREFETCHES_TABLE_INDEX_BITS 9
// #define L1D_PREV_PREFETCHES_TABLE_ENTRIES (1 << L1D_PREV_PREFETCHES_TABLE_INDEX_BITS)
// #define L1D_PREV_PREFETCHES_TABLE_MASK (L1D_PREV_PREFETCHES_TABLE_ENTRIES - 1)
// #define L1D_PREV_PREFETCHES_TABLE_NULL_POINTER L1D_CURRENT_PAGES_TABLE_ENTRIES

// // We do not have access to the MSHR, so we aproximate it using this structure.
// //多个预取表的条目的指针可能指向同一个页的条目的索引
// typedef struct __l1d_prev_prefetch_entry {
//   uint64_t page_addr_pointer; // 6 bits
//   uint64_t offset; // 6 bits
//   uint64_t time_lat; // 16 bits // time if not completed, latency if completed
//   bool completed; // 1 bit
// } l1d_prev_prefetch_entry;

// l1d_prev_prefetch_entry l1d_prev_prefetches_table[NUM_CPUS][L1D_PREV_PREFETCHES_TABLE_ENTRIES];
// uint64_t l1d_prev_prefetches_table_head[NUM_CPUS];

// void l1d_init_prev_prefetches_table() {
//   l1d_prev_prefetches_table_head[l1d_cpu_id] = 0;
//   for (int i = 0; i < L1D_PREV_PREFETCHES_TABLE_ENTRIES; i++) {
//     l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_PREFETCHES_TABLE_NULL_POINTER;
//   }
// }

// uint64_t l1d_find_prev_prefetch_entry(uint64_t pointer, uint64_t offset) {
//   for (int i = 0; i < L1D_PREV_PREFETCHES_TABLE_ENTRIES; i++) {
//     if (l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer == pointer
// 	&& l1d_prev_prefetches_table[l1d_cpu_id][i].offset == offset) return i;
//   }
//   return L1D_PREV_PREFETCHES_TABLE_ENTRIES;
// }

// void l1d_add_prev_prefetches_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
//   // First find for coalescing
//   if (l1d_find_prev_prefetch_entry(pointer, offset) != L1D_PREV_PREFETCHES_TABLE_ENTRIES) return;

//   // Allocate a new entry (evict old one if necessary)
//   l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].page_addr_pointer = pointer;
//   l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].offset = offset;
//   l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].time_lat = cycle & L1D_TIME_MASK;
//   l1d_prev_prefetches_table[l1d_cpu_id][l1d_prev_prefetches_table_head[l1d_cpu_id]].completed = false;
//   l1d_prev_prefetches_table_head[l1d_cpu_id] = (l1d_prev_prefetches_table_head[l1d_cpu_id] + 1) & L1D_PREV_PREFETCHES_TABLE_MASK;
// }

// void l1d_reset_pointer_prev_prefetches(uint64_t pointer) {
//   for (int i = 0; i < L1D_PREV_PREFETCHES_TABLE_ENTRIES; i++) {
//     if (l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer == pointer) {
//       l1d_prev_prefetches_table[l1d_cpu_id][i].page_addr_pointer = L1D_PREV_PREFETCHES_TABLE_NULL_POINTER;
//     }
//   }
// }

// void l1d_reset_entry_prev_prefetches_table(uint64_t pointer, uint64_t offset) {
//   uint64_t index = l1d_find_prev_prefetch_entry(pointer, offset);
//   if (index != L1D_PREV_PREFETCHES_TABLE_ENTRIES) {
//     l1d_prev_prefetches_table[l1d_cpu_id][index].page_addr_pointer = L1D_PREV_PREFETCHES_TABLE_NULL_POINTER;
//   }
// }

// uint64_t l1d_get_and_set_latency_prev_prefetches_table(uint64_t pointer, uint64_t offset, uint64_t cycle) {
//   uint64_t index = l1d_find_prev_prefetch_entry(pointer, offset); 
//   if (index == L1D_PREV_PREFETCHES_TABLE_ENTRIES) return 0;
//   if (!l1d_prev_prefetches_table[l1d_cpu_id][index].completed) {
//     l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat = l1d_get_latency(cycle, l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat);
//     l1d_prev_prefetches_table[l1d_cpu_id][index].completed = true;
//   }    
//   return l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat;
// }

// uint64_t l1d_get_latency_prev_prefetches_table(uint64_t pointer, uint64_t offset) {
//   uint64_t index = l1d_find_prev_prefetch_entry(pointer, offset);
//   if (index == L1D_PREV_PREFETCHES_TABLE_ENTRIES) return 0;
//   if (!l1d_prev_prefetches_table[l1d_cpu_id][index].completed) return 0;
//   return l1d_prev_prefetches_table[l1d_cpu_id][index].time_lat;
// }


// // RECORD PAGES TABLE

// //#define L1D_RECORD_PAGES_TABLE_INDEX_BITS 10
// #define L1D_RECORD_PAGES_TABLE_ENTRIES (((1 << 10) + (1 << 8) + (1 << 7)) - 1) // ((1 << L1D_RECORD_PAGES_TABLE_INDEX_BITS) - 1) // Null pointer for ip table
// #define L1D_TRUNCATED_PAGE_ADDR_BITS 32 // 4 bytes
// #define L1D_TRUNCATED_PAGE_ADDR_MASK (((uint64_t)1 << L1D_TRUNCATED_PAGE_ADDR_BITS) -1)

// typedef struct __l1d_record_page_entry {
//   uint64_t page_addr; // 4 bytes
//   uint64_t u_vector; // 8 bytes
//   uint64_t first_offset; // 6 bits
//   int berti; // 7 bits
//   uint64_t lru; // 10 bits
// } l1d_record_page_entry;


// l1d_record_page_entry l1d_record_pages_table[NUM_CPUS][L1D_RECORD_PAGES_TABLE_ENTRIES];

// void l1d_init_record_pages_table() {
//   for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
//     l1d_record_pages_table[l1d_cpu_id][i].page_addr = 0;
//     l1d_record_pages_table[l1d_cpu_id][i].u_vector = 0;
//     l1d_record_pages_table[l1d_cpu_id][i].lru = i;
//   }
// }

// uint64_t l1d_get_lru_record_pages_entry() {
//   uint64_t lru = L1D_RECORD_PAGES_TABLE_ENTRIES;
//   for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
//     l1d_record_pages_table[l1d_cpu_id][i].lru++;
//     if (l1d_record_pages_table[l1d_cpu_id][i].lru == L1D_RECORD_PAGES_TABLE_ENTRIES) {
//       l1d_record_pages_table[l1d_cpu_id][i].lru = 0;
//       lru = i;
//     } 
//   }
//   assert(lru != L1D_RECORD_PAGES_TABLE_ENTRIES);
//   return lru;
// }

// void l1d_update_lru_record_pages_table(uint64_t index) {
//   assert(index < L1D_RECORD_PAGES_TABLE_ENTRIES);
//   for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
//     if (l1d_record_pages_table[l1d_cpu_id][i].lru < l1d_record_pages_table[l1d_cpu_id][index].lru) { // Found
//       l1d_record_pages_table[l1d_cpu_id][i].lru++;
//     }
//   }
//   l1d_record_pages_table[l1d_cpu_id][index].lru = 0;
// }

// void l1d_add_record_pages_table(uint64_t index, uint64_t page_addr, uint64_t vector, uint64_t first_offset, int berti) {
//   assert(index < L1D_RECORD_PAGES_TABLE_ENTRIES);
//   l1d_record_pages_table[l1d_cpu_id][index].page_addr = page_addr & L1D_TRUNCATED_PAGE_ADDR_MASK;
//   l1d_record_pages_table[l1d_cpu_id][index].u_vector = vector;
//   l1d_record_pages_table[l1d_cpu_id][index].first_offset = first_offset;
//   l1d_record_pages_table[l1d_cpu_id][index].berti = berti;    
//   l1d_update_lru_record_pages_table(index);
// }

// uint64_t l1d_get_entry_record_pages_table(uint64_t page_addr, uint64_t first_offset) {
//   uint64_t trunc_page_addr = page_addr & L1D_TRUNCATED_PAGE_ADDR_MASK;
//   for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
//     if (l1d_record_pages_table[l1d_cpu_id][i].page_addr == trunc_page_addr
// 	&& l1d_record_pages_table[l1d_cpu_id][i].first_offset == first_offset) { // Found
//       return i;
//     }
//   }
//   return L1D_RECORD_PAGES_TABLE_ENTRIES;
// }

// uint64_t l1d_get_entry_record_pages_table(uint64_t page_addr) {
//   uint64_t trunc_page_addr = page_addr & L1D_TRUNCATED_PAGE_ADDR_MASK;  
//   for (int i = 0; i < L1D_RECORD_PAGES_TABLE_ENTRIES; i++) {
//     if (l1d_record_pages_table[l1d_cpu_id][i].page_addr == trunc_page_addr) { // Found
//       return i;
//     }
//   }
//   return L1D_RECORD_PAGES_TABLE_ENTRIES;
// }

// void l1d_copy_entries_record_pages_table(uint64_t index_from, uint64_t index_to) {
//   assert(index_from < L1D_RECORD_PAGES_TABLE_ENTRIES);
//   assert(index_to < L1D_RECORD_PAGES_TABLE_ENTRIES);
//   l1d_record_pages_table[l1d_cpu_id][index_to].page_addr = l1d_record_pages_table[l1d_cpu_id][index_from].page_addr;
//   l1d_record_pages_table[l1d_cpu_id][index_to].u_vector = l1d_record_pages_table[l1d_cpu_id][index_from].u_vector;
//   l1d_record_pages_table[l1d_cpu_id][index_to].first_offset = l1d_record_pages_table[l1d_cpu_id][index_from].first_offset;
//   l1d_record_pages_table[l1d_cpu_id][index_to].berti = l1d_record_pages_table[l1d_cpu_id][index_from].berti;    
//   l1d_update_lru_record_pages_table(index_to);
// }


// // IP TABLE

// #define L1D_IP_TABLE_INDEX_BITS 10
// #define L1D_IP_TABLE_ENTRIES (1 << L1D_IP_TABLE_INDEX_BITS)
// #define L1D_IP_TABLE_INDEX_MASK (L1D_IP_TABLE_ENTRIES - 1)
// #define L1D_IP_TABLE_NULL_POINTER L1D_RECORD_PAGES_TABLE_ENTRIES

// uint64_t l1d_ip_table[NUM_CPUS][L1D_IP_TABLE_ENTRIES]; // 11 bits

// void l1d_init_ip_table() {
//   for (int i = 0; i < L1D_IP_TABLE_ENTRIES; i++) {
//     l1d_ip_table[l1d_cpu_id][i] = L1D_IP_TABLE_NULL_POINTER;
//   }
// }


// // TABLE MOVEMENTS

// // Sumarizes the content to the current page to be evicted
// // From all timely requests found, we record the best 
// void l1d_record_current_page(uint64_t index_current) {
//   if (l1d_current_pages_table[l1d_cpu_id][index_current].u_vector) { // Valid entry
//     uint64_t record_index = l1d_ip_table[l1d_cpu_id][l1d_current_pages_table[l1d_cpu_id][index_current].ip & L1D_IP_TABLE_INDEX_MASK];
//     assert(record_index < L1D_RECORD_PAGES_TABLE_ENTRIES);
//     uint64_t confidence;
//     l1d_add_record_pages_table(record_index,
// 			       l1d_current_pages_table[l1d_cpu_id][index_current].page_addr,
// 			       l1d_current_pages_table[l1d_cpu_id][index_current].u_vector,
// 			       l1d_current_pages_table[l1d_cpu_id][index_current].first_offset,
// 			       l1d_get_berti_current_pages_table(index_current, confidence));
//   }
// }

// // INTERFACE

// void CACHE::l1d_prefetcher_initialize() 
// {
//   l1d_cpu_id = cpu;
//   cout << "CPU " << cpu << " L1D Berti prefetcher" << endl;
  
//   l1d_init_current_pages_table();
//   l1d_init_prev_requests_table();
//   l1d_init_prev_prefetches_table();
//   l1d_init_record_pages_table();
//   l1d_init_ip_table();
// }

// void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit, uint8_t type, uint8_t critical_ip_flag)
// {
//   l1d_cpu_id = cpu;
//   uint64_t line_addr = addr >> LOG2_BLOCK_SIZE;
//   uint64_t page_addr = line_addr >> L1D_PAGE_BLOCKS_BITS;
//   uint64_t offset = line_addr & L1D_PAGE_OFFSET_MASK;

//   // Update current pages table
//   // Find the entry
//   //可以认为pages table是按照内容进行索引的，返回页地址相同的那一个条目的索引
//   uint64_t index = l1d_get_current_pages_entry(page_addr);

//   // If not accessed recently
//   //如果没有这个页的信息，或者当前页的访问偏移在之前没有出现过，那么就为其添加条目
//   if (index == L1D_CURRENT_PAGES_TABLE_ENTRIES
//       || !l1d_requested_offset_current_pages_table(index, offset)) 
//   {
//     //有页信息但是没有offset
//     //cout << "OFFSETS: " << hex << ip << " " << page_addr << " " << dec << offset << endl;

//     //这种情况是是新的offset,这种情况说明当前访问是hot page,还不是cold page，没有页需要被剔除到
//     //recorded tabel中，也就是这个页之前被访问过
//     if (index < L1D_CURRENT_PAGES_TABLE_ENTRIES) 
//     { // Found
//       //cout << " FOUND" << endl;

//       // If offset found, already requested, so return;
//       if (l1d_requested_offset_current_pages_table(index, offset)) return;

//       //更新对应条目的offset向量，更新所有pages条目的lru优先级，并且返回第一次访问这个page的ip地址
//       uint64_t first_ip = l1d_update_demand_current_pages_table(index, offset);

//       //l1d_ip_table中记录这个ip指向的pages——table的条目的索引，因为这是个hot page
//       assert(l1d_ip_table[l1d_cpu_id][first_ip & L1D_IP_TABLE_INDEX_MASK] != L1D_IP_TABLE_NULL_POINTER);

//       // Update berti
//       //确认是预取回来的块，并且已经获得了预取这个块回来所需要的时间，那么就可以获得及时
//       //访问回来得到的delta
//       if (cache_hit) 
//       {
//         //在预取表中查找当前是否是预取的块，如果是并且已经预取完成了，那么就可以获得取回这个数据所需要的时间
// 	      uint64_t pref_latency = l1d_get_latency_prev_prefetches_table(index, offset);

//         //确认是预取回来的块，并且已经获得了预取这个块回来所需要的时间，那么就可以获得及时
//         //访问回来得到的delta
// 	      if (pref_latency != 0) 
//         {
//           // Find berti distance from pref_latency cycles before
//           int berti[L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS]; 

//           l1d_get_berti_prev_requests_table(index, offset, current_core_cycle[cpu] - pref_latency, berti);
//           for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS; i++) 
//           {
//             if (berti[i] == 0) break; 
//             assert(abs(berti[i]) < L1D_PAGE_BLOCKS);

//             //更新或者加入每一个delta的得分
//             l1d_add_berti_current_pages_table(index, berti[i]);
//           }

//           // Eliminate a prev prefetch since it has been used
//           //可以消除预取表中这一项了，因为已经统计过信息，使用完成了，相当于预取命中了
//           l1d_reset_entry_prev_prefetches_table(index, offset);
// 	      }  
//       }
    
//       //如果第一次访问这个页的ip与当前访问这个页的ip不同
//       if (first_ip != ip) 
//       {
//         // Assign same pointer to group IPs
//         //所有访问同一个页的ip表的指针都等于访问这个页的第一个ip指向记录表的指针
//         //这个与前面的预取并不矛盾
//         l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = l1d_ip_table[l1d_cpu_id][first_ip & L1D_IP_TABLE_INDEX_MASK]; 
//       }
//     } 
//     //如果这次访问的是一个冷页，主要是将页驱逐，并且为新页分配一个ip table的指针
//     else 
//     { 
//       //没有页信息，第一次访问一个页
//       // Not found: Add entry
     
//       // Find victim and clear pointers to it
//       uint64_t victim_index = l1d_get_lru_current_pages_entry(); // already updates lru
//       assert(victim_index < L1D_CURRENT_PAGES_TABLE_ENTRIES);

//       //所有指向被驱逐的页的条目的指针都要被置为无效
//       l1d_reset_pointer_prev_requests(victim_index); // Not valid anymore
//       l1d_reset_pointer_prev_prefetches(victim_index); // Not valid anymore

//       //将被剔除的页面的信息放入到record表中
//       // Copy victim to record table
//       //在record中的索引已经早已分配好，由表项中的第一次访问的页的ip来确定
//       //在将current table中的页分配给record table中的页时，需要将offset vector，以及得分最大的
//       //offset以及offset对应的得分都传递给record表,但是offset的得分没有用到
//       l1d_record_current_page(victim_index);

//       // Add new current page
//       index = victim_index;
//       l1d_add_current_pages_table(index, page_addr, ip & L1D_IP_TABLE_INDEX_MASK, offset);

//       // Set pointer in IP table
//       //对于一个cold page,在record表中查找是否有对应的条目,因为page在currrent table中
//       //的存在是有生命周期的，所以很有可能recorded table中还存在有对应的条目
//       //同一个page在record table中可能有多个项，因为访问的offset不同
//       uint64_t index_record = l1d_get_entry_record_pages_table(page_addr, offset);
//       // The ip pointer is null
//       //如果访问这个当前的冷页的第一个ip在ip table中没有索引
//       //这种情况下又分了record table中是否有对应的条目来讨论
//       if (l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] == L1D_IP_TABLE_NULL_POINTER) 
//       { 
//         //在表中没有ip没有record，也就是这个指针和页面都没有出现过
//         //那么就为其在record表中分配一个新的条目，并且将ip 表中的ip对应的指针指向record table的项
//         if (index_record == L1D_RECORD_PAGES_TABLE_ENTRIES) 
//         { // Page not recorded
//           // Get free record page pointer.
//           uint64_t new_pointer = l1d_get_lru_record_pages_entry();
//           l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = new_pointer;
//         }
//         //如果这个ip不存在，但是这个页在record table中存在，说明上一次访问这个页的第一个ip和当前的ip不同
//         //就将只需要将现在的ip也指向record table中的那个页
//         else 
//         {
//           l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = index_record;
// 	      }
//       } 
//       //这种情况是，ip table中有索引（同一个ip但是访问的是其他页），但是record table中没有索引，
//       //或者record table中有索引，但是指向的不是同一个页，这种也是同一个ip但是访问的是其他页
//       else if (l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] != index_record) 
//       {
//         // If the current IP is valid, but points to another address
//         // we replicate it in another record entry (lru)
//         // such that the recorded page is not deleted when the current entry summarizes
//         //由于是新页，所以需要重新分配一个页
//         uint64_t new_pointer = l1d_get_lru_record_pages_entry();
//         //并且将ip对应的页的信息先赋给这个新页，并且更新ip的指针，为这个新页的地址
//         l1d_copy_entries_record_pages_table(l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK], new_pointer);
//         l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK] = new_pointer;
//       }
//     }

//     //记录访问的信息表
//     l1d_add_prev_requests_table(index, offset, current_core_cycle[cpu]);
       
//     // PREDICT
//     uint64_t u_vector = 0;
//     //first是当前访问的hot page的第一个偏移
//     uint64_t first_offset = l1d_current_pages_table[l1d_cpu_id][index].first_offset;
//     int berti = 0;
//     bool recorded = false;
    
//     //分别找到三种匹配，ip 匹配，ip通常与page联系在一起，但是找到的是record page的索引，或者没有
//     //pgo是page和offset的索引，所以找的是，当前页和页的第一个offset都满足的record page的索引
//     //pg是page的索引，找的是page的索引
//     uint64_t ip_pointer = l1d_ip_table[l1d_cpu_id][ip & L1D_IP_TABLE_INDEX_MASK];
//     uint64_t pgo_pointer = l1d_get_entry_record_pages_table(page_addr, first_offset);
//     uint64_t pg_pointer = l1d_get_entry_record_pages_table(page_addr);
//     uint64_t berti_confidence = 0;
//     int current_berti = l1d_get_berti_current_pages_table(index, berti_confidence);
//     uint64_t match_confidence = 0;
    
//     // If match with current page+first_offset, use record
//     //如果page和起始的offset都匹配，并且当前在这个页的访问轨迹和之前record table中记录的访问轨迹完全一致
//     //这种属于高度匹配
//     if (pgo_pointer != L1D_RECORD_PAGES_TABLE_ENTRIES
//     	&& (l1d_record_pages_table[l1d_cpu_id][pgo_pointer].u_vector | l1d_current_pages_table[l1d_cpu_id][index].u_vector) == l1d_record_pages_table[l1d_cpu_id][pgo_pointer].u_vector) 
//     {
//       u_vector =  l1d_record_pages_table[l1d_cpu_id][pgo_pointer].u_vector;
//       berti =  l1d_record_pages_table[l1d_cpu_id][pgo_pointer].berti;
//       match_confidence = 1; // High confidence
//       recorded = true;
//     } 
//     else
//     // If match with current ip+first_offset, use record
//     //如果当前ip访问的页的偏移，与这个ip之前访问的页的偏移相同，而且页内的访问轨迹也相同
//     if (l1d_record_pages_table[l1d_cpu_id][ip_pointer].first_offset == first_offset
//     	&& (l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector | l1d_current_pages_table[l1d_cpu_id][index].u_vector) == l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector) 
//     {
//       u_vector =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector;
//       berti =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].berti;
//       match_confidence = 1; // High confidence
//       recorded = true;
//     } else
//     // If no exact match, trust current if it has already a berti
//     //如果没有匹配的，但是有分数比较高的delta,那么就用当前这个hot page的信息，并且只选择一个得分最高的delta
//     if (current_berti != 0 && berti_confidence >= L1D_BERTI_CTR_MED_HIGH_CONFIDENCE) 
//     { // Medium-High confidence
//       u_vector =  l1d_current_pages_table[l1d_cpu_id][index].u_vector;
//       berti = current_berti;
//     } else
//     // If match with current page, use record
//     //如果当前hot page没有合适的，但是有这个页之前的信息
//     if (pg_pointer != L1D_RECORD_PAGES_TABLE_ENTRIES) 
//     { // Medium confidence
//       u_vector =  l1d_record_pages_table[l1d_cpu_id][pg_pointer].u_vector;
//       berti =  l1d_record_pages_table[l1d_cpu_id][pg_pointer].berti;
//       recorded = true;
//     } else
//     // If match with current ip, use record
//     //这个ip应该会指向这个页，所以这个循环应该是进不去的？
//     if (l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector) 
//     { // Medium confidence
//       u_vector =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].u_vector;
//       berti =  l1d_record_pages_table[l1d_cpu_id][ip_pointer].berti;
//       recorded = true;
//     }

//     // Burst for the first access of a page or if pending bursts
//     //如果当前是对一个hot page的第一次访问，或者是上一次突发结束的不为0，说明需要突发
//     if (first_offset == offset || l1d_current_pages_table[l1d_cpu_id][index].last_burst != 0) 
//     {
//       uint64_t first_burst;
//       if (l1d_current_pages_table[l1d_cpu_id][index].last_burst != 0) 
//       {
//         first_burst = l1d_current_pages_table[l1d_cpu_id][index].last_burst;
//         l1d_current_pages_table[l1d_cpu_id][index].last_burst = 0;
//       } 
//       else if (berti >= 0) 
//       {
// 	      first_burst = offset + 1;
//       }	
//       else 
//       {
// 	      first_burst = offset - 1;
//       }


//       if (recorded && match_confidence) 
//       {
// 	      int bursts = 0;
// 	      if (berti > 0) 
//         {
//           for (uint64_t i = first_burst; i < offset+berti; i++) 
//           {
//             if (i >= L1D_PAGE_BLOCKS) break; // Stay in the page
//             // Only if previously requested and not demanded
//             uint64_t pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | i;
//             uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
//             uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
//             uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
//             //l1d_requested_offset_current_pages_table这个hot page最近有没有这个pf_offset的请求
//             if ((((uint64_t)1 << i) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset)) 
//             {
//               if (PQ.occupancy < PQ.SIZE && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
//               {
//                 //只要PQ.occupancy < PQ.SIZE,那么prefetched就会为真
//                 bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
//                 if (prefetched) 
//                 {
//                   assert(pf_page_addr == page_addr);
//                   l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
//                   bursts++;
//                 }
//               } 
//               //如过发不完就记住当前的地址，下一次继续发
//               else 
//               { // record last burst
//                 l1d_current_pages_table[l1d_cpu_id][index].last_burst = i;
//                 break;
//               }
//             }
//           }
// 	      } 
//         else if (berti < 0) 
//         {
//           for (int i = first_burst; i > ((int)offset)+berti; i--) 
//           {
//             if (i < 0) break; // Stay in the page
//             // Only if previously requested and not demanded
//             uint64_t pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | i;
//             uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
//             uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
//             uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
//             if ((((uint64_t)1 << i) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset)) 
//             {
//               if (PQ.occupancy < PQ.SIZE && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
//               {
//                 bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
//                 if (prefetched) 
//                 {
//                   assert(pf_page_addr == page_addr);
//                   l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
//                   bursts++;
//                 }
// 	            } 
//               else 
//               { // record last burst
// 		            l1d_current_pages_table[l1d_cpu_id][index].last_burst = i;
// 		            break;
// 	            }
// 	          }
// 	        }
// 	      } 
//         else 
//         { // berti == 0 (zig zag of all)
// 	        for (int i = first_burst, j = (first_offset << 1) - i;
// 	        i < L1D_PAGE_BLOCKS || j >= 0; i++, j = (first_offset << 1) - i) 
//           {
//             // Only if previously requested and not demanded
//             // Dir ++
//             uint64_t pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | i;
//             uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
//             uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
//             uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
// 	          if ((((uint64_t)1 << i) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset) && (i < L1D_PAGE_BLOCKS)) 
//             {
//               if (PQ.occupancy < PQ.SIZE && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
//               {
//                 bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
//                 if (prefetched) 
//                 {
//                   assert(pf_page_addr == page_addr);
//                   l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
//                   bursts++;
//                 }
//               } 
//               else 
//               { // record last burst
// 		            l1d_current_pages_table[l1d_cpu_id][index].last_burst = i;
// 		            break;
// 	            }
// 	          }
//             // Dir --
//             pf_line_addr = (page_addr << L1D_PAGE_BLOCKS_BITS) | j;
//             pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
//             pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
//             pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
//             if ((((uint64_t)1 << j) & u_vector)&& !l1d_requested_offset_current_pages_table(index, pf_offset)&&(j>0)&&(j<L1D_PAGE_BLOCKS)) 
//             {
//               if (PQ.occupancy < PQ.SIZE && bursts < L1D_MAX_NUM_BURST_PREFETCHES) 
//               {
//                 bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
//                 if (prefetched) 
//                 {
//                   assert(pf_page_addr == page_addr);
//                   l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
//                   bursts++;
//                 }
//               } else 
//               {
//                 // record only positive burst
//               }
//             }
// 	        }
// 	      }  
//       } 
//       else 
//       { // not recorded
//       }	
//     }
      
//     if (berti != 0) 
//     {
//       uint64_t pf_line_addr = line_addr + berti;
//       uint64_t pf_addr = pf_line_addr << LOG2_BLOCK_SIZE;
//       uint64_t pf_page_addr = pf_line_addr >> L1D_PAGE_BLOCKS_BITS;
//       uint64_t pf_offset = pf_line_addr & L1D_PAGE_OFFSET_MASK;
//       if (!l1d_requested_offset_current_pages_table(index, pf_offset) // Only prefetch if not demanded
// 	      && (!match_confidence || (((uint64_t)1 << pf_offset) & u_vector))&&(pf_page_addr == page_addr)) 
//       { // And prev. accessed
// 	      bool prefetched = prefetch_line(ip, addr, pf_addr, FILL_L1, 0);
// 	      if (prefetched) 
//         {
//           assert(pf_page_addr == page_addr);
//           l1d_add_prev_prefetches_table(index, pf_offset, current_core_cycle[cpu]);
// 	      }
//       }
//     }
//   }
// }

// void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr,uint64_t addr, uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, uint64_t evicted_addr, uint32_t metadata_in)
// {
//   l1d_cpu_id = cpu;
//   uint64_t line_addr = (addr >> LOG2_BLOCK_SIZE);
//   uint64_t page_addr = line_addr >> L1D_PAGE_BLOCKS_BITS;
//   uint64_t offset = line_addr & L1D_PAGE_OFFSET_MASK;

//   uint64_t pointer_prev = l1d_get_current_pages_entry(page_addr);
  
//   if (pointer_prev < L1D_CURRENT_PAGES_TABLE_ENTRIES) { // Not found, not entry in prev requests
//     uint64_t pref_latency = l1d_get_and_set_latency_prev_prefetches_table(pointer_prev, offset, current_core_cycle[cpu]);
//     uint64_t demand_latency = l1d_get_latency_prev_requests_table(pointer_prev, offset, current_core_cycle[cpu]);
    
//     // First look in prefetcher, since if there is a hit, it is the time the miss started
//     // If no prefetch, then its latency is the demand one
//     if (pref_latency == 0) {
//       pref_latency = demand_latency;
//     }     
    
//     if (demand_latency != 0) { // Not found, berti will not be found neither
      
//       // Find berti (distance from pref_latency + demand_latency cycles before
//       int berti[L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS]; 
//       l1d_get_berti_prev_requests_table(pointer_prev, offset, current_core_cycle[cpu] - (pref_latency + demand_latency), berti);
//       for (int i = 0; i < L1D_CURRENT_PAGES_TABLE_NUM_BERTI_PER_ACCESS; i++) {
// 	if (berti[i] == 0) break;
// 	assert(abs(berti[i]) < L1D_PAGE_BLOCKS);
// 	l1d_add_berti_current_pages_table(pointer_prev, berti[i]);
//       }
//     }
//   }

//   uint64_t victim_index = l1d_get_current_pages_entry(evicted_addr >> LOG2_PAGE_SIZE);
//   if (victim_index < L1D_CURRENT_PAGES_TABLE_ENTRIES) {
//     // Copy victim to record table
//     l1d_record_current_page(victim_index);
//     l1d_remove_current_table_entry(victim_index);
//   }
// }

// void CACHE::l1d_prefetcher_final_stats()
// {
//     cout << "CPU " << cpu << " L1D berti prefetcher final stats" << endl;
// }
