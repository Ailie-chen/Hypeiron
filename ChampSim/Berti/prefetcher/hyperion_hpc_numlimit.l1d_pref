
#include "vbertimix_small.h"
#include "bingo_frame.h"
#define LANZAR_INT 8
#define PAGE_MASK 0xFFF

# define SIZE_6

# if defined(SIZE_1)
# define PAGE_ACCUMULATE_TABLES     (16)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (16)
# define PAGE_STRIDE_NUMBERS        (16)
# elif defined(SIZE_2)
# define PAGE_ACCUMULATE_TABLES     (16)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (64)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_3)
# define PAGE_ACCUMULATE_TABLES     (16)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (64)
# define PAGE_STRIDE_NUMBERS        (16)
# elif defined(SIZE_4)
# define PAGE_ACCUMULATE_TABLES     (16)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (96)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_5)
# define PAGE_ACCUMULATE_TABLES     (32)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (16)
# define PAGE_STRIDE_NUMBERS        (16)
# elif defined(SIZE_6)
# define PAGE_ACCUMULATE_TABLES     (32)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (64)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_7)
# define PAGE_ACCUMULATE_TABLES     (32)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (64)
# define PAGE_STRIDE_NUMBERS        (16)
# elif defined(SIZE_8)
# define PAGE_ACCUMULATE_TABLES     (32)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (96)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_9)
# define PAGE_ACCUMULATE_TABLES     (16)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (32)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_10)
# define PAGE_ACCUMULATE_TABLES     (16)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (48)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_11)
# define PAGE_ACCUMULATE_TABLES     (64)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (32)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_12)
# define PAGE_ACCUMULATE_TABLES     (64)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (32)
# define PAGE_STRIDE_NUMBERS        (16)
# elif defined(SIZE_13)
# define PAGE_ACCUMULATE_TABLES     (64)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (64)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_14)
# define PAGE_ACCUMULATE_TABLES     (64)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (64)
# define PAGE_STRIDE_NUMBERS        (16)
# elif defined(SIZE_15)
# define PAGE_ACCUMULATE_TABLES     (64)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (96)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_16)
# define PAGE_ACCUMULATE_TABLES     (64)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (96)
# define PAGE_STRIDE_NUMBERS        (16)
# elif defined(SIZE_17)
# define PAGE_ACCUMULATE_TABLES     (8)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (32)
# define PAGE_STRIDE_NUMBERS        (8)
# elif defined(SIZE_18)
# define PAGE_ACCUMULATE_TABLES     (8)
# define OFFSET_RECORD_NUMBERS      (8)
# define PAGE_STRIDE_TABLES         (64)
# define PAGE_STRIDE_NUMBERS        (8)
#endif
// Last edit: 27 - Sept - 2021 12:10

// FIFO queue
//#define SIZE_RR 16
//uint64_t RR[NUM_CPUS][SIZE_RR] = {0};
//uint64_t RR_cycle[NUM_CPUS][SIZE_RR] = {0};
//uint64_t RR_dx[NUM_CPUS] = {0};

bool spec_intructions_complete;
struct PAGE_SETTING{
    const uint64_t REGION_SIZE = 32 * 1024;
    const uint64_t PAGE_ACCUMULATE_TABLE=PAGE_ACCUMULATE_TABLES;
    const uint64_t OFFSET_RECORD_NUMBER=OFFSET_RECORD_NUMBERS;
    const uint64_t PAGE_STRIDE_TABLE=PAGE_STRIDE_TABLES;
    const uint64_t PAGE_STRIDE_NUMBER=PAGE_STRIDE_NUMBERS;

    const uint64_t PC_ACCUMULATE_TABLE=16;
    const uint64_t ADDR_RECORD_NUMBER=8;
    const uint64_t PC_STRIDE_TABLE=16;
    const uint64_t PC_STRIDE_NUMBER=8;

    const uint64_t STRIDE_COUNT_TABLE=32;
    const uint64_t INTERVAL=100;
    const float PAGE_L1_THRESHOLD=0.75;
    const float PAGE_L2_THRESHOLD=0.15;
    const float PAGE_LLC_THRESHOLD=0.40;

    const float PC_L1_THRESHOLD=0.65;
    const float PC_L2_THRESHOLD=0.20;
    const float PC_LLC_THRESHOLD=0.35;

    // const float PAGE_L1_THRESHOLD=2.0;
    // const float PAGE_L2_THRESHOLD=2.0;
    // const float PAGE_LLC_THRESHOLD=2.0;
    const float GLOBAL_STRIDE_THRESHOLD=1.00;
    const float GLOBAL_STRIDE_THRESHOLD_LLC=GLOBAL_STRIDE_THRESHOLD;
    const int MAX_PF_S = 16;
    const int MAX_PF_LAUNCH_S = 6;
    const int PAGE_MAX_PF_LAUNCH_S = 8;
    const int ALL_MAX_PF = 12;
    const uint64_t PAGE_CONFIDENCE_MAX = 16;
    const uint64_t PAGE_LANZAR_INT = 8;



    void print(){
            cerr  << "====================================================="<<endl;
            cerr  <<  "PAGE_ACCUMULATE_TABLE:         "   <<PAGE_ACCUMULATE_TABLE<<endl;
            cerr  << "====================================================="<<endl;
    }

};


uint8_t warmup_flag_l1 = 0;

void notify_prefetch(uint64_t addr, uint64_t tag, uint32_t cpu, uint64_t cycle)
{
    //这个是预取时，进入到缺失状态寄存器的时间
    latency_table_add(addr, tag, cpu, 0, cycle & TIME_MASK);
}

bool compare_greater_stride_t(stride_t a, stride_t b)
{
    if (a.rpl == L1 && b.rpl != L1) return 1;
    else if (a.rpl != L1 && b.rpl == L1) return 0;
    else
    {
        if (a.rpl == L2 && b.rpl != L2) return 1;
        else if (a.rpl != L2 && b.rpl == L2) return 0;
        else
        {
            if (a.rpl == L2R && b.rpl != L2R) return 1;
            if (a.rpl != L2R && b.rpl == L2R) return 0;
            else
            {
                if (std::abs(a.stride) < std::abs(b.stride)) return 1;
                return 0;
            }
        }
    }
}

bool compare_greater_stride_t_per(stride_t a, stride_t b)
{
    if (a.per > b.per) return 1;
    else
    {
        if (std::abs(a.stride) < std::abs(b.stride)) return 1;
        return 0;
    }
}

/******************************************************************************/
/*                      Latency table functions                               */
/******************************************************************************/
void latency_table_init(uint32_t cpu)
{
    /*
     * Init pqmshr (latency) table
     *
     * Parameters:
     *      - cpu: cpu
     */
    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        latencyt[cpu][i].tag  = 0;
        latencyt[cpu][i].addr = 0;
        latencyt[cpu][i].time = 0;
        latencyt[cpu][i].pf   = 0;
    }
}

uint64_t latency_table_get_ip(uint64_t line_addr, uint32_t cpu)
{
    /*
     * Return 1 or 0 if the addr is or is not in the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *
     * Return: 1 if the line is in the latency table, otherwise 0
     */

    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Search if the line_addr already exists
        if (latencyt[cpu][i].addr == line_addr && latencyt[cpu][i].tag) 
            return latencyt[cpu][i].tag;
    }

    return 0;
}

uint8_t latency_table_add(uint64_t line_addr, uint64_t tag, uint32_t cpu, 
        uint8_t pf)
{
    /*
     * Save if possible the new miss into the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *  - access: is the entry accessed by a demand request
     */
    return latency_table_add(line_addr, tag, cpu, pf, current_core_cycle[cpu] & TIME_MASK);
}

uint8_t latency_table_add(uint64_t line_addr, uint64_t tag, uint32_t cpu, 
        uint8_t pf, uint64_t cycle)
{
    /*
     * Save if possible the new miss into the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *  - access: is theh entry accessed by a demand request
     *  - cycle: time to use in the latency table
     *
     * Return: 1 if the addr already exist, otherwise 0.
     */

    latency_table_t *free;
    free = nullptr;

    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Search if the line_addr already exists. If it exist we does not have
        // to do nothing more
        if (latencyt[cpu][i].addr == line_addr) 
        {
            latencyt[cpu][i].time = cycle;
            latencyt[cpu][i].tag  = tag;
            latencyt[cpu][i].pf   = pf;
            return latencyt[cpu][i].pf;
        }

        // We discover a free space into the latency table, save it for later
        //if (latencyt[cpu][i].addr == 0) free = &latencyt[cpu][i];
        if (latencyt[cpu][i].tag == 0) free = &latencyt[cpu][i];
    }

    // No free space!! This cannot be truth
    if (free == nullptr) return 0;

    // We save the new entry into the latency table
    free->addr = line_addr;
    free->time = cycle;
    free->tag  = tag;
    free->pf   = pf;

    return free->pf;
}

uint64_t latency_table_del(uint64_t line_addr, uint32_t cpu)
{
    /*
     * Remove the address from the latency table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *
     *  Return: the latency of the address
     */
    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Line already in the table
        if (latencyt[cpu][i].addr == line_addr)
        {
            uint64_t latency = (current_core_cycle[cpu] & TIME_MASK)
                - latencyt[cpu][i].time; // Calculate latency

            //latencyt[cpu][i].addr = 0; // Free the entry
            latencyt[cpu][i].tag  = 0; // Free the entry
            latencyt[cpu][i].time = 0; // Free the entry
            latencyt[cpu][i].pf   = 0; // Free the entry

            // Return the latency
            return latency;
        }
    }

    // We should always track the misses
    //assert(0);
    return 0;
}

uint64_t latency_table_get(uint64_t line_addr, uint32_t cpu)
{
    /*
     * Return 1 or 0 if the addr is or is not in the pqmshr (latency) table
     *
     * Parameters:
     *  - line_addr: address without cache offset
     *  - cpu: actual cpu
     *
     * Return: 1 if the line is in the latency table, otherwise 0
     */

    for (uint32_t i = 0; i < LATENCY_TABLE_SIZE; i++)
    {
        // Search if the line_addr already exists
        if (latencyt[cpu][i].addr == line_addr) return latencyt[cpu][i].time;
    }

    return 0;
}

/******************************************************************************/
/*                       Shadow Cache functions                               */
/******************************************************************************/
void shadow_cache_init(uint32_t cpu)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     */
    for (uint8_t i = 0; i < L1D_SET; i++)
    {
        for (uint8_t ii = 0; ii < L1D_WAY; ii++)
        {
            scache[cpu][i][ii].addr = 0;
            scache[cpu][i][ii].lat  = 0;
            scache[cpu][i][ii].pf   = 0;
        }
    }
}

uint8_t shadow_cache_add(uint32_t cpu, uint32_t set, uint32_t way, 
        uint64_t line_addr, uint8_t pf, uint64_t latency)
{
    /*
     * Add block to shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - set: cache set
     *      - way: cache way
     *      - addr: cache block v_addr
     *      - access: the cache is access by a demand
     */
    scache[cpu][set][way].addr = line_addr;
    scache[cpu][set][way].pf   = pf;
    scache[cpu][set][way].lat  = latency;
    return scache[cpu][set][way].pf;
}

uint8_t shadow_cache_get(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) return 1;
        }
    }

    return 0;
}

uint8_t shadow_cache_pf(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) 
            {
                scache[cpu][i][ii].pf = 0;
                return 1;
            }
        }
    }

    return 0;
}

uint8_t shadow_cache_is_pf(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) return scache[cpu][i][ii].pf;
        }
    }

    return 0;
}

uint8_t shadow_cache_latency(uint32_t cpu, uint64_t line_addr)
{
    /*
     * Init shadow cache
     *
     * Parameters:
     *      - cpu: cpu
     *      - addr: cache block v_addr
     *
     * Return: 1 if the addr is in the l1d cache, 0 otherwise
     */

    for (uint32_t i = 0; i < L1D_SET; i++)
    {
        for (uint32_t ii = 0; ii < L1D_WAY; ii++)
        {
            if (scache[cpu][i][ii].addr == line_addr) return scache[cpu][i][ii].lat;
        }
    }
    assert(0);
    return 0;
}


/******************************************************************************/
/*                       History Table functions                               */
/******************************************************************************/
// Auxiliar history table functions

struct PageAccInfo{
    uint64_t offset;
    uint64_t latency;
};
class PageAccululateTableData {
  public:
    // vector<bool> offsets;
    // vector<uint64_t> latencys;
    // vector<uint64_t> counter;

    deque<int> offsets;
    deque<uint64_t> latencys;
    // vector<struct PageAccInfo> page_history;
};

class PageAccululateTable : public LRUFullyAssociativeCache<PageAccululateTableData> {
    typedef LRUFullyAssociativeCache<PageAccululateTableData> Super;
    public:
        PageAccululateTable(int size, int pattern_len, int offset_number) : Super(size) , pattern_len(pattern_len),offset_number(offset_number){
            cerr<<"PatternAccululateTable sets: "<< num_sets<<" ways: "<<num_ways<<endl;
        }

        int insert(uint64_t block_number, uint64_t lat ){
            uint64_t region_num =  (block_number / this->pattern_len)&PAGE_MASK;
            int region_offset   =  block_number % this->pattern_len;
            Entry *entry = Super::find(region_num);
            if (!entry){
                // vector<bool> offsets(this->pattern_len, false);
                // vector<uint64_t> latencys(this->pattern_len, 0);
                // vector<uint64_t> counter(this->pattern_len, 0);
                deque<int> offsets;
                deque<uint64_t> latencys;
                offsets.push_back(region_offset);
                latencys.push_back(lat);
                // offsets[region_offset] = true;
                // latencys[region_offset]=lat;
                // counter[region_offset]=1;
                Entry victim =  Super::insert(region_num, {offsets,latencys});
                this->set_mru(region_num);
                if(this->debug_level>=2){
                    cerr  << "[PAT] Insert new page: "<<  region_num << ", latency: " << lat << " offsets: "<< dequeToString(offsets) <<endl;
                }
                return 0;
            }else{

                this->set_mru(region_num);
                // entry->data.offsets[region_offset] = true;
                // entry->data.latencys[region_offset] = lat;
                // entry->data.counter[region_offset] = entry->data.counter[region_offset] + 1;

                for (size_t i = 0; i < entry->data.offsets.size(); ++i) {
                    if(entry->data.offsets[i] == region_offset){
                        return 0;
                    }
                } 

                if(entry->data.offsets.size()>= this->offset_number){
                    entry->data.offsets.pop_front();
                    entry->data.latencys.pop_front();
                }
                entry->data.offsets.push_back(region_offset);
                entry->data.latencys.push_back(lat);

                if(this->debug_level>=2){
                    cerr  << "[PAT] Accumulate new page number: "<<  region_num << ", latency: " << lat << " offsets: "<< dequeToString(entry->data.offsets) <<endl;
                }
                return 0;
            }
        }

        int get_stride(uint64_t block_number, uint64_t lat, uint64_t cycle, int stride[2] ){
            uint64_t region_num =  (block_number / this->pattern_len)&PAGE_MASK;
            int region_offset   =  block_number % this->pattern_len;
            Entry *entry = Super::find(region_num);
            if (!entry){
                if(this->debug_level>=2){
                    cerr  << "[PAT] No stride. page number: "<<  region_num << ", latency: " << lat << " cycle: "<< cycle <<endl;
                }
                return 0;
            }else{
                if (cycle < lat) return 0;
                cycle = cycle - lat;
                int cnt = 0;
                this->set_mru(region_num);


                for (size_t i = 0; i < entry->data.offsets.size(); ++i) {
                    if( entry->data.latencys[i] < cycle ){
                        if((region_offset - entry->data.offsets[i]) != 0){
                            stride[cnt] = region_offset - entry->data.offsets[i];
                            cnt = cnt + 1;
                        }
                        if(this->debug_level>=2){
                            cerr  << "[PAT] stride: " << stride[i]<<" offset " << region_offset<<" "<<entry->data.offsets[i] << " page number: "<<  region_num << ", latency: " << lat << " cycle: "<< cycle <<endl;
                        }  
                    }      
                }

                return cnt;
            }
        }
    
    private:
        uint64_t pattern_len;
        uint64_t offset_number;
};

struct stride_info {
    int stride;
    uint64_t conf;
    uint64_t prefetch_level; 
    uint64_t lru;
};

class PageStrideTableData {
  public:
    // vector<uint64_t> strides;
    // vector<uint64_t> conf;
    vector<stride_info> stride_conf;
    // vector<uint64_t> train_stride;
    uint64_t total;
};

bool compareByConf(const stride_info& s1, const stride_info& s2) {

    if(s1.prefetch_level != s2.prefetch_level){
        return s1.prefetch_level < s2.prefetch_level ;
    }else{
        return s1.conf > s2.conf;
    }
    
    
    //  if(s1.conf != s2.conf){
    //     return s1.conf > s2.conf;
    // }else{
    //     return s1.lru>s2.lru;
    // }
}

bool compareByOnlyConf(const stride_info& s1, const stride_info& s2) {
    return s1.conf > s2.conf;
}

class PageStrideTable : public LRUFullyAssociativeCache<PageStrideTableData> {
    typedef LRUFullyAssociativeCache<PageStrideTableData> Super;
    public:
        PageStrideTable(int size, uint64_t pattern_len, uint64_t stride_num, float l1_thres, float l2_thres, float llc_thres, 
           int page_confident_max, int page_first) : Super(size) ,
         pattern_len(pattern_len),stride_num(stride_num),
         l1_thres(l1_thres), l2_thres(l2_thres), llc_thres(llc_thres),
         page_confident_max(page_confident_max), page_first(page_first)
        //  , page_l1_thres(page_l1_thres),  page_l2_thres(page_l2_thres), page_l3_thres(page_l3_thres)
        {
            cerr<<"PatternAccululateTable sets: "<< num_sets<<" ways: "<<num_ways<<endl;
        }

        int add_stride_conf(uint64_t block_number, int s){
            uint64_t region_num =  (block_number / this->pattern_len)&PAGE_MASK;
            int region_offset   =  block_number % this->pattern_len;
            Entry *entry = Super::find(region_num);

            if (!entry){
                vector<stride_info> add_stride;
                add_stride.push_back({s, 1, NO_PREFETCH, 1});
                Entry victim =  Super::insert(region_num, {add_stride, 1});
                this->set_mru(region_num);
                if(this->debug_level>=2){
                    cerr  << "[PST] insert page : "  << " page number: "<< region_num  << ", insert stride: " << s  <<endl;
                }   
                return 0;
            }else{
                this->set_mru(region_num);
                for ( auto& pair : entry->data.stride_conf) {
                    if(pair.stride == s){
                        pair.conf = pair.conf+1;
                        pair.lru = entry->data.total;
                        if(pair.conf > entry->data.total){
                            if(this->debug_level>=2){
                                cerr  << "[PST] insert page : "  << " page number: "<< region_num  << ", total: " << entry->data.total <<" conf: "<<pair.conf <<endl;
                                assert(0);
                            }                            
                        }

                        // assert(pair.conf <= entry->data.total);
                        if(this->debug_level>=2){
                            cerr  << "[PST] insert page : "  << " page number: "<< region_num  << ", accumulate stride: " << s  <<endl;
                        }
                        return 0;
                    }
                }
                std::sort(entry->data.stride_conf.begin(), entry->data.stride_conf.end(), compareByConf);
                if(entry->data.stride_conf.size() >= this->stride_num){
                    entry->data.stride_conf.pop_back();
                }
                entry->data.stride_conf.push_back({s,1, NO_PREFETCH, entry->data.total});
                return 0;
            }
        }

        void add_page_conf(uint64_t block_number){
            uint64_t region_num =  (block_number / this->pattern_len)&PAGE_MASK;
            int region_offset   =  block_number % this->pattern_len;
            Entry *entry = Super::find(region_num);
            if (entry){
                if(this->debug_level>=2){
                    cerr  << "[PST] add page count: "  << " page number: "<< region_num  << ", total: " << entry->data.total <<endl;
                }
                entry->data.total = entry->data.total + 1;
                if(entry->data.total == page_confident_max){
                    for ( auto& pair : entry->data.stride_conf) {
                        float conf_rate = 1.0*pair.conf/entry->data.total ;
                        if( conf_rate > l1_thres ){
                            pair.prefetch_level = L1;
                        }else if(conf_rate > l2_thres){
                            pair.prefetch_level = L2;
                        }else if(conf_rate > llc_thres){
                            pair.prefetch_level = L2R;
                        }
                        else{
                            pair.prefetch_level = NO_PREFETCH;
                        }
                        if(this->debug_level>=2){
                            cerr  << "[PST] add_page_conf: "  << " page number: "<< region_num  << ", stride: " << pair.stride <<", conf: "<< pair.conf<<" level: "<<pair.prefetch_level <<endl;
                        }
                        pair.conf = 0;
                        pair.lru = 0;
                    }
                    entry->data.total = 1;
                }
            }
        }

        vector<stride_info> get_conf_stride(uint64_t block_number){
            uint64_t region_num =  (block_number / this->pattern_len)&PAGE_MASK;
            int region_offset   =  block_number % this->pattern_len;
            vector<stride_info> conf_stride;
            Entry *entry = Super::find(region_num);
            if (!entry){
                // return 0;
                 if(this->debug_level>=2){
                    cerr  << "[PST] get conf stride: "  << " No this page"<<endl;
                }


                // cerr  << "[PST] get conf stride: "  << " No this page"<<endl;
                return conf_stride;
            }else{
                std::sort(entry->data.stride_conf.begin(), entry->data.stride_conf.end(), compareByConf);
                // cerr  << "[PST] get conf stride: "  << " page number: "<< region_num <<", size: " << entry->data.stride_conf.size() <<" total: "<< entry->data.total <<endl;
                for ( auto& pair : entry->data.stride_conf) {
                    if(pair.stride!=0 && pair.prefetch_level < NO_PREFETCH){
                        conf_stride.push_back({pair.stride, pair.conf, pair.prefetch_level});
                    }
                }

                if( conf_stride.size() ==0 && entry->data.total >= page_first){
                    std::sort(entry->data.stride_conf.begin(), entry->data.stride_conf.end(), compareByOnlyConf);
                    for ( auto& pair : entry->data.stride_conf) {
                        float conf_rate = 1.0*pair.conf/entry->data.total ;
                        if( conf_rate > (l1_thres+0.15) ){
                            conf_stride.push_back({pair.stride, pair.conf, L1});
                        }else if(conf_rate > (l2_thres+0.15)){
                            conf_stride.push_back({pair.stride, pair.conf, L2});
                        }else{
                            break;
                        }
                    }
                }
                if(this->debug_level>=2){
                    cerr  << "[PST] get conf stride: ";
                    for ( auto& pair : conf_stride) {
                        cerr << pair.stride << " ";
                    }
                    cerr << endl;
                }
                return conf_stride;
            }
        }
    private:
        uint64_t pattern_len;
        uint64_t stride_num;
        float l1_thres, l2_thres, llc_thres;
        uint64_t page_confident_max, page_first; 
        // float   page_l1_thres, page_l2_thres, page_l3_thres;
};

struct PCAccInfo{
    uint64_t addr;
    uint64_t latency;
};
class PCAccululateTableData {
  public:
    // vector<bool> offsets;
    // vector<uint64_t> latencys;
    // vector<uint64_t> counter;

    deque<uint64_t> addrs;
    deque<uint64_t> latencys;
};
class PCAccululateTable : public LRUFullyAssociativeCache<PCAccululateTableData> {
    typedef LRUFullyAssociativeCache<PCAccululateTableData> Super;
    public:
        PCAccululateTable(int size, int pattern_len, int addr_number) : Super(size) , pattern_len(pattern_len),addr_number(addr_number){
            cerr<<"PatternAccululateTable sets: "<< num_sets<<" ways: "<<num_ways<<endl;
        }

        int insert(uint64_t block_number,uint64_t pc_tag, uint64_t lat ){
            block_number = block_number&ADDR_MASK;
            Entry *entry = Super::find(pc_tag);
            if (!entry){
                // vector<bool> offsets(this->pattern_len, false);
                // vector<uint64_t> latencys(this->pattern_len, 0);
                // vector<uint64_t> counter(this->pattern_len, 0);
                deque<uint64_t> addrs;
                deque<uint64_t> latencys;
                addrs.push_back(block_number);
                latencys.push_back(lat);
                // offsets[region_offset] = true;
                // latencys[region_offset]=lat;
                // counter[region_offset]=1;
                Entry victim =  Super::insert(pc_tag, {addrs,latencys});
                this->set_mru(pc_tag);
                if(this->debug_level>=2){
                    // cerr  << "[PCAT] Insert new pc: "<<  pc_tag << ", latency: " << lat << " offsets: "<< dequeToString(addrs) <<endl;
                }
                return 0;
            }else{

                this->set_mru(pc_tag);
                // entry->data.offsets[region_offset] = true;
                // entry->data.latencys[region_offset] = lat;
                // entry->data.counter[region_offset] = entry->data.counter[region_offset] + 1;

                for (size_t i = 0; i < entry->data.addrs.size(); ++i) {
                    if(entry->data.addrs[i] == block_number){
                        return 0;
                    }
                } 

                if(entry->data.addrs.size()>= this->addr_number){
                    entry->data.addrs.pop_front();
                    entry->data.latencys.pop_front();
                }
                entry->data.addrs.push_back(block_number);
                entry->data.latencys.push_back(lat);

                if(this->debug_level>=2){
                    // cerr  << "[PCAT] Accumulate new pc_tag: "<<  pc_tag << ", latency: " << lat << " offsets: "<< dequeToString(entry->data.addrs) <<endl;
                }
                return 0;
            }
        }

        int get_stride(uint64_t block_number,uint64_t pc_tag, uint64_t lat, uint64_t cycle, int64_t stride[] ){
            block_number = block_number & ADDR_MASK;
            Entry *entry = Super::find(pc_tag);
            if (!entry){
                if(this->debug_level>=2){
                    cerr  << "[PCAT] No stride. page number: "<<  pc_tag << ", latency: " << lat << " cycle: "<< cycle <<endl;
                }
                return 0;
            }else{
                if (cycle < lat) return 0;
                cycle = cycle - lat;
                int cnt = 0;
                this->set_mru(pc_tag);

                for (size_t i =  entry->data.addrs.size(); i-- > 0;) {
                    if( entry->data.latencys[i] < cycle ){
                        // if(entry->data.addrs[i] == block_number){
                        //     return cnt;
                        // }           
                        int64_t delta;
                        delta = (int64_t)(block_number - entry->data.addrs[i]);
                        // for(size_t k = 0; k < cnt; k++){
                        //     if(stride[k]==delta){
                        //         return cnt;
                        //     }
                        // }
                        stride[cnt] = delta;
                        cnt = cnt + 1;
                        // if((std::abs(delta) < (1 << STRIDE_MASK))&&delta!=0){
                        //     stride[cnt] = delta;
                        //     cnt = cnt + 1;
                        // }
                        if(this->debug_level>=2){
                            cerr  << "tag" << pc_tag<<"[PCAT] stride: " << delta<<" addr " << block_number<<" "<<entry->data.addrs[i] << ", latency: " << lat << " cycle: "<< cycle <<endl;
                        }           
                    }      
                }

                return cnt;
            }
        }
    
    private:
        uint64_t pattern_len;
        uint64_t addr_number;
};
class PCStrideTableData {
  public:
    // vector<uint64_t> strides;
    // vector<uint64_t> conf;
    vector<stride_info> stride_conf;
    // vector<uint64_t> train_stride;
    uint64_t total;
};
class PCStrideTable : public LRUFullyAssociativeCache<PCStrideTableData> {
    typedef LRUFullyAssociativeCache<PCStrideTableData> Super;
    public:
        PCStrideTable(int size, uint64_t pattern_len, uint64_t stride_num, float l1_thres, float l2_thres, float llc_thres, 
           int page_confident_max, int page_first) : Super(size) ,
         pattern_len(pattern_len),stride_num(stride_num),
         l1_thres(l1_thres), l2_thres(l2_thres), llc_thres(llc_thres),
         page_confident_max(page_confident_max), page_first(page_first)
        //  , page_l1_thres(page_l1_thres),  page_l2_thres(page_l2_thres), page_l3_thres(page_l3_thres)
        {
            cerr<<"PatternAccululateTable sets: "<< num_sets<<" ways: "<<num_ways<<endl;
        }

        int add_stride_conf(uint64_t block_number,uint64_t pc_tag, int s){
            Entry *entry = Super::find(pc_tag);

            if (!entry){
                vector<stride_info> add_stride;
                add_stride.push_back({s, 1, NO_PREFETCH, 1});
                Entry victim =  Super::insert(pc_tag, {add_stride, 1});
                this->set_mru(pc_tag);
                if(this->debug_level>=2){
                    cerr  << "[PCST] insert pc : "  << " pc_tag: "<< pc_tag << ", insert stride: " << s  <<endl;
                }   
                return 0;
            }else{
                this->set_mru(pc_tag);
                for ( auto& pair : entry->data.stride_conf) {
                    if(pair.stride == s){
                        pair.conf = pair.conf+1;
                        pair.lru = entry->data.total;
                        if(pair.conf > entry->data.total){
                            if(this->debug_level>=2){
                                cerr  << "[PCST] insert pc : "  << "pc_tag: "<< pc_tag  << ", total: " << entry->data.total <<" conf: "<<pair.conf <<endl;
                                assert(0);
                            }                            
                        }

                        // assert(pair.conf <= entry->data.total);
                        if(this->debug_level>=2){
                            cerr  << "[PCST] insert pc : "  << " pc_tag: "<< pc_tag  << ", accumulate stride: " << s  <<endl;
                        }
                        return 0;
                    }
                }
                // if(entry->data.stride_conf.size() > this->stride_num ){
                //     entry->data.stride_conf.pop_back();
                // }else if(entry->data.stride_conf.size() == this->stride_num && (entry->data.stride_conf[entry->data.stride_conf.size()].prefetch_level == L1)){
                //    return 0;
                // }
                // else if(entry->data.stride_conf.size() == this->stride_num && (entry->data.stride_conf[entry->data.stride_conf.size()].prefetch_level != L1)){
                //     entry->data.stride_conf.pop_back();
                //     entry->data.stride_conf.push_back({s,1, NO_PREFETCH, entry->data.total});
                // }else{
                //    entry->data.stride_conf.push_back({s,1, NO_PREFETCH, entry->data.total}); 
                // }
                std::sort(entry->data.stride_conf.begin(), entry->data.stride_conf.end(), compareByConf);
                if(entry->data.stride_conf.size() >= this->stride_num){
                    entry->data.stride_conf.pop_back();
                }
                entry->data.stride_conf.push_back({s,1, NO_PREFETCH, entry->data.total});
                return 0;
            }
        }

        void add_page_conf(uint64_t block_number, uint64_t pc_tag){
            Entry *entry = Super::find(pc_tag);
            if (entry){
                if(this->debug_level>=2){
                    cerr  << "[PCST] add page count: "  << " pc_tag: "<< pc_tag  << ", total: " << entry->data.total <<endl;
                }
                entry->data.total = entry->data.total + 1;
                if(entry->data.total == page_confident_max){
                    for ( auto& pair : entry->data.stride_conf) {
                        float conf_rate = 1.0*pair.conf/entry->data.total ;
                        if( conf_rate > l1_thres ){
                            pair.prefetch_level = L1;
                        }else if(conf_rate > l2_thres){
                            pair.prefetch_level = L2;
                        }else if(conf_rate > llc_thres){
                            pair.prefetch_level = L2R;
                        }
                        else{
                            pair.prefetch_level = NO_PREFETCH;
                        }
                        if(this->debug_level>=2){
                            cerr  << "[PCST] add_page_conf: "  << " pc_tag: "<< pc_tag  << ", stride: " << pair.stride <<", conf: "<< pair.conf<<" level: "<<pair.prefetch_level <<endl;
                        }
                        pair.conf = 0;
                        pair.lru = 0;
                    }
                    entry->data.total = 1;
                }
            }
        }

        vector<stride_info> get_conf_stride(uint64_t block_number, uint64_t pc_tag){
            vector<stride_info> conf_stride;
            Entry *entry = Super::find(pc_tag);
            if (!entry){
                // return 0;
                 if(this->debug_level>=2){
                    cerr  << "[PCST] get conf stride: "  << " No this pc_tag"<<endl;
                }


                // cerr  << "[PST] get conf stride: "  << " No this page"<<endl;
                return conf_stride;
            }else{
                std::sort(entry->data.stride_conf.begin(), entry->data.stride_conf.end(), compareByConf);
                // cerr  << "[PST] get conf stride: "  << " page number: "<< region_num <<", size: " << entry->data.stride_conf.size() <<" total: "<< entry->data.total <<endl;
                for ( auto& pair : entry->data.stride_conf) {
                    if(pair.stride!=0 && pair.prefetch_level < NO_PREFETCH){
                        conf_stride.push_back({pair.stride, pair.conf, pair.prefetch_level});
                    }
                }

                if( conf_stride.size() ==0 && entry->data.total >= page_first){
                    std::sort(entry->data.stride_conf.begin(), entry->data.stride_conf.end(), compareByOnlyConf);
                    for ( auto& pair : entry->data.stride_conf) {
                        float conf_rate = 1.0*pair.conf/entry->data.total ;
                        if(pair.stride != 0){
                            if( conf_rate > 0.8 ){
                                conf_stride.push_back({pair.stride, pair.conf, L1});
                            }else if(conf_rate > 0.35){
                                conf_stride.push_back({pair.stride, pair.conf, L2});
                            }else{
                                break;
                            }
                        }
                    }
                }
                if(this->debug_level>=2){
                    cerr  << "[PCST] get conf stride: ";
                    for ( auto& pair : conf_stride) {
                        cerr << pair.stride << " ";
                    }
                    cerr << endl;
                }
                return conf_stride;
            }
        }
    private:
        uint64_t pattern_len;
        uint64_t stride_num;
        float l1_thres, l2_thres, llc_thres;
        uint64_t page_confident_max, page_first; 
        // float   page_l1_thres, page_l2_thres, page_l3_thres;
};


class MIX {
  public:

    MIX(struct PAGE_SETTING setting)
        : setting(setting), pattern_len(setting.REGION_SIZE>>LOG2_BLOCK_SIZE),
        pat(setting.PAGE_ACCUMULATE_TABLE, setting.REGION_SIZE>>LOG2_BLOCK_SIZE, setting.OFFSET_RECORD_NUMBER),
        pst(setting.PAGE_STRIDE_TABLE, setting.REGION_SIZE>>LOG2_BLOCK_SIZE, setting.PAGE_STRIDE_NUMBER, 
        setting.PAGE_L1_THRESHOLD, setting.PAGE_L2_THRESHOLD, setting.PAGE_LLC_THRESHOLD, setting.PAGE_CONFIDENCE_MAX, setting.PAGE_LANZAR_INT),
        bat(setting.PC_ACCUMULATE_TABLE, setting.REGION_SIZE>>LOG2_BLOCK_SIZE, setting.ADDR_RECORD_NUMBER),
        bst(setting.PC_STRIDE_TABLE, setting.REGION_SIZE>>LOG2_BLOCK_SIZE, setting.PC_STRIDE_NUMBER, 
        setting.PC_L1_THRESHOLD, setting.PC_L2_THRESHOLD, setting.PC_LLC_THRESHOLD, setting.PAGE_CONFIDENCE_MAX, setting.PAGE_LANZAR_INT)
        {   
        }
    


    void update_stride(uint64_t block_number, uint64_t pc_tag, uint64_t latency, uint64_t  cycle){
        int strides[setting.OFFSET_RECORD_NUMBER];
        // cerr<<"get stride "<<endl;
        for(uint16_t i = 0; i <setting.OFFSET_RECORD_NUMBER; i++){
            strides[i]= 0;
        }
        int cnt = pat.get_stride(block_number, latency, cycle, strides);
        for (int i=0; i<cnt; i++){
            // assert(cnt<6);
            if(i==0){
                pst.add_page_conf(block_number);
            }
            pst.add_stride_conf(block_number, strides[i]);
        }
        // for(uint16_t i = 0; i < 256; i++){
        //     strides[i]= 0;
        // }
        int64_t strides_pc[setting.ADDR_RECORD_NUMBER];
        for(uint16_t i = 0; i <setting.ADDR_RECORD_NUMBER; i++){
            strides_pc[i]= 0;
        }
        cnt = 0;
        cnt = bat.get_stride(block_number, pc_tag, latency, cycle, strides_pc);
        for (int i=0; i<cnt; i++){
            // assert(cnt<6);
            if(i==0){
                bst.add_page_conf(block_number, pc_tag);
            }
            if((std::abs(strides_pc[i]) < (1 << STRIDE_MASK))&&strides_pc[i]!=0){
                bst.add_stride_conf(block_number, pc_tag,strides_pc[i]);
            }
        }
        
    }

    void cache_fill(uint64_t cpu, uint64_t pc_tag, uint64_t line_addr, uint64_t latency, uint64_t cycle){


        uint64_t block_number =  line_addr;
        
        // uint64_t block_number = ((line_addr >> 1) ^ (line_addr >> 4));
        // block_number = block_number&PAGE_MASK ;
        

        if (this->debug_level >= 2) {
            uint64_t region_number = (block_number / this->pattern_len)&PAGE_MASK;
            int region_offset = block_number % this->pattern_len;    
            cerr << "[MIX] cache fill(block_number: "  << block_number << ", region_number:" << region_number <<" region_offset: " << region_offset << ", latency: " << latency << " )" << endl;
        }
        update_stride(block_number, pc_tag, latency, cycle);
        
    }

    void access(uint32_t cpu, uint64_t pc_tag, uint64_t line_addr, uint8_t cache_hit){

        uint64_t block_number =  line_addr;

        // uint64_t block_number = ((line_addr >> 1) ^ (line_addr >> 4));
        // block_number = block_number&PAGE_MASK ;

        uint64_t region_number = (block_number / this->pattern_len)&PAGE_MASK;
        int region_offset = block_number % this->pattern_len;
        
        if (this->debug_level >= 2) {
            uint64_t cycle = current_core_cycle[cpu] & TIME_MASK;
            cerr << endl  << "[MIX] access(block_number: "  << block_number << ", region_number:" << region_number <<" region_offset: " << region_offset <<  " )" << endl;
            cerr << "[MIX] access "<<" cache_hit: "   << (cache_hit==1) <<" pf: " << (shadow_cache_is_pf(cpu, block_number) == 1 )<<", cycle "<< cycle  << endl;
            // cerr<<" rate: "<<rate<< endl;
        }

        
        if (!cache_hit){
            if(this->debug_level >= 2)
            {
                // std::cout << "M" << std::endl;
            }
            uint64_t cycle = current_core_cycle[cpu] & TIME_MASK;
            latency_table_add(line_addr, pc_tag, cpu, 1);
            pat.insert(block_number, cycle);
            bat.insert(block_number,pc_tag, cycle);
        }else if (cache_hit && shadow_cache_is_pf(cpu, line_addr)){
            if(this->debug_level >= 2)
            {
                // std::cout << "PH" << std::endl;
            }
            uint64_t cycle = current_core_cycle[cpu] & TIME_MASK;
            uint64_t latency = shadow_cache_latency(cpu, line_addr);
            shadow_cache_pf(cpu, line_addr);
            update_stride(block_number, pc_tag,latency, cycle);  
            pat.insert(block_number, cycle);
            bat.insert(block_number,pc_tag, cycle);    
            
                  
                    
        }else{
            if(this->debug_level >= 2)
            {
                // std::cout << "H" << std::endl;
            }
            shadow_cache_pf(cpu, line_addr);
        }
        // vector<stride_info> conf_stride;
        // conf_stride = this->pst.get_conf_stride(block_number);
    }
    vector<stride_info> pc_get_conf_stride(uint64_t block_number, uint64_t pc_tag){
        vector<stride_info> conf_stride_pc;
        conf_stride_pc = this->bst.get_conf_stride(block_number,pc_tag);
        return conf_stride_pc;
    }

    vector<stride_info> page_get_conf_stride(uint64_t block_number){
        vector<stride_info> conf_stride_page;
        conf_stride_page = this->pst.get_conf_stride(block_number);
        return conf_stride_page;
    }
    


    void set_debug_level(int debug_level) { 
        this->debug_level = debug_level; 
        pat.set_debug_level(debug_level);
        pst.set_debug_level(debug_level);
        bat.set_debug_level(debug_level);
        bst.set_debug_level(debug_level);
    }
    
    private:
        struct PAGE_SETTING setting;
        int pattern_len;
        PageAccululateTable pat;
        PageStrideTable pst;
        PCAccululateTable bat;
        PCStrideTable bst;
        int debug_level = 0;

};

vector<MIX> prefetchers;

struct PAGE_SETTING setting;

void CACHE::l1d_prefetcher_initialize() 
{
    shadow_cache_init(cpu);
    latency_table_init(cpu);



    prefetchers = vector<MIX>(NUM_CPUS, MIX(setting));

    std::cout << "History Sets: " << HISTORY_TABLE_SET << std::endl;
    std::cout << "History Ways: " << HISTORY_TABLE_WAY << std::endl;
    std::cout << "BERTI Size: " << BERTI_TABLE_SIZE << std::endl;
    std::cout << "BERTI Stride Size: " << BERTI_TABLE_STRIDE_SIZE << std::endl;
    
    for(int i =0; i<NUM_CPUS; i++){
        prefetchers[i].set_debug_level(0);
    }
    spec_intructions_complete = false;
}

void CACHE::l1d_prefetcher_operate(uint64_t addr, uint64_t ip, uint8_t cache_hit,
        uint8_t type, uint8_t critical_ip_flag)
{
    assert(type == LOAD || type == RFO);

    if(warmup_complete[cpu] && warmup_flag_l1 == 0){
        warmup_flag_l1 = 1;
        for(int i =0; i<NUM_CPUS; i++){
            prefetchers[i].set_debug_level(0);
        }
    }

    uint64_t line_addr = (addr >> LOG2_BLOCK_SIZE); // Line addr
    uint64_t pc = ip;
    ip = ((ip >> 1) ^ (ip >> 4));
    //ip = (ip >> 1) ^ (ip >> 4) ^ (ip >> 8);
    ip = ip & IP_MASK;

    
    
    prefetchers[cpu].access(cpu, ip, line_addr, cache_hit);



    int total_prefetch = 0;
    int berti_launched = 0;
    uint16_t i = 0;
    uint16_t j = 0;
    vector<stride_info> conf_stride_pc;
    conf_stride_pc = prefetchers[cpu].pc_get_conf_stride(line_addr, ip);
    if(conf_stride_pc.size() > 0){
        for (; i < conf_stride_pc.size() && i < setting.MAX_PF_LAUNCH_S; i++){


            
            uint64_t p_addr = (line_addr + conf_stride_pc[i].stride) << LOG2_BLOCK_SIZE;
            uint64_t p_b_addr = (p_addr >> LOG2_BLOCK_SIZE);

            if (!latency_table_get(p_addr, cpu)){
                int fill_level = FILL_L1;
                float mshr_load = ((float) MSHR.occupancy / (float) MSHR_SIZE) * 100;
                if (conf_stride_pc[i].prefetch_level == L1 && mshr_load < MSHR_LIMIT){
                    fill_level = FILL_L1;
                } else if (conf_stride_pc[i].prefetch_level == L1 
                || conf_stride_pc[i].prefetch_level == L2 
                || conf_stride_pc[i].prefetch_level == L2R){ 
                    fill_level = FILL_L2;
                }else{
                    break;
                }

                if (prefetch_line(ip, addr, p_addr, fill_level, 1)){
                    // assert(0);
                    berti_launched++;
                    total_prefetch++;
                }

            }
        }
    } 
    
    vector<stride_info> conf_stride_page;
    conf_stride_page = prefetchers[cpu].page_get_conf_stride(line_addr);
    int page_launched = 0;
    if(conf_stride_page.size() > 0){
        for ( ; j <conf_stride_page.size(); j++ ) {

            if( (page_launched >= setting.PAGE_MAX_PF_LAUNCH_S) || ((page_launched + berti_launched) >= setting.ALL_MAX_PF)  ){
                break;
            }

            
            uint64_t p_addr = (line_addr + conf_stride_page[j].stride) << LOG2_BLOCK_SIZE;
            uint64_t p_b_addr = (p_addr >> LOG2_BLOCK_SIZE);

            if (!latency_table_get(p_addr, cpu)){
                int fill_level = FILL_L1;
                float mshr_load = ((float) MSHR.occupancy / (float) MSHR_SIZE) * 100;
                if (conf_stride_page[j].prefetch_level == L1 && mshr_load < MSHR_LIMIT){
                    fill_level = FILL_L1;
                } else if (conf_stride_page[j].prefetch_level == L2 || conf_stride_page[j].prefetch_level == L1){ 
                    fill_level = FILL_L2;
                } else if (conf_stride_page[j].prefetch_level == L2R){ 
                    fill_level = FILL_LLC;
                } else{
                    break;
                }

                if (prefetch_line(ip, addr, p_addr, fill_level, 1)){
                    // assert(0);
                    page_launched++;
                    total_prefetch++;
                }

            }
        }
    }
}

void CACHE::l1d_prefetcher_notify_about_dtlb_eviction(uint64_t addr, 
        uint32_t set, uint32_t way, uint8_t prefetch, uint64_t evicted_addr, 
        uint32_t metadata_in)
{

}

void CACHE::l1d_prefetcher_cache_fill(uint64_t v_addr, uint64_t addr, 
        uint32_t set, uint32_t way, uint8_t prefetch, uint64_t v_evicted_addr, 
        uint64_t evicted_addr, uint32_t metadata_in)
{
    uint64_t line_addr = (v_addr >> LOG2_BLOCK_SIZE); // Line addr
    uint64_t line_evicted = (v_evicted_addr >> LOG2_BLOCK_SIZE); // Line addr

    // Remove @ from latency table
    uint64_t tag     = latency_table_get_ip(line_addr, cpu);
    uint64_t cycle   = latency_table_get(line_addr, cpu);
    uint64_t latency = latency_table_del(line_addr, cpu);

    if (latency > LAT_MASK) latency = 0;

    // Add to the shadow cache
    shadow_cache_add(cpu, set, way, line_addr, prefetch, latency);

    if (latency != 0 && !prefetch)
    {
        prefetchers[cpu].cache_fill(cpu, tag,line_addr, latency,cycle);
    }
}

void CACHE::l1d_prefetcher_final_stats()
{

}
